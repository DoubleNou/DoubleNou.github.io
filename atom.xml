<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nou的技术逆袭</title>
  <icon>https://www.gravatar.com/avatar/437514e75b4c3fbc3705e56df986d682</icon>
  <subtitle>无所谓挑战、情怀无限</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.nouyc.com/"/>
  <updated>2020-03-24T04:50:27.818Z</updated>
  <id>https://www.nouyc.com/</id>
  
  <author>
    <name>Nou</name>
    <email>709824656@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跟着小马哥学Spring第二天</title>
    <link href="https://www.nouyc.com/2020/03/23/%E8%B7%9F%E7%9D%80%E5%B0%8F%E9%A9%AC%E5%93%A5%E5%AD%A6Spring/"/>
    <id>https://www.nouyc.com/2020/03/23/跟着小马哥学Spring/</id>
    <published>2020-03-23T12:51:03.000Z</published>
    <updated>2020-03-24T04:50:27.818Z</updated>
    
    <content type="html"><![CDATA[<p>#依赖注入方式</p><ol><li><p>构造注入<br>有参数、或者无参构造器</p></li><li><p>set注入<br>经常用到的注入</p></li><li><p>延伸注入<br>c、p空间注入 但是需要schema/p | c</p></li></ol><p>#依赖注入方式</p><p> 单例、原型、request、session、websocket</p><p>#自动装配Bean</p><p> schema/context。和 context-config</p><p>#推荐使用java-config配置Spring-Bean</p><p>#静态代理模式</p><ol><li><p>抽象角色、真实角色、代理角色、客户访问代理角色</p><p>代理模式好处: 上层不关心下层，公共服务方便方法扩展<br>代理模式缺点: 一个真实角色就要new 一个代理角色。代码量很大</p></li></ol><p>#动态代理模式</p><ol><li><p>解决静态代理的问题</p></li><li><p>运用反射机制实现动态代理，看下我的dubbo的consumer通过代理类拿到的Service</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static&lt;T&gt; T getProxy(<span class="class"><span class="keyword">Class</span> <span class="title">interfaceClass</span>)&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), <span class="keyword">new</span> <span class="class"><span class="keyword">Class</span>[]&#123;<span class="title">interfaceClass</span>&#125;, <span class="title">new</span> <span class="title">InvocationHandler</span>() &#123;</span></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> &#123;</span></span><br><span class="line">                Protocol protocol = ProtocolFactory.getProtocol();</span><br><span class="line">                Invocation invocation = <span class="keyword">new</span> Invocation(interfaceClass.getName(), <span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>), <span class="function"><span class="keyword">method</span>.<span class="title">getParameterTypes</span>(</span>), args);</span><br><span class="line"></span><br><span class="line">                URL url = RemoteRegister.random(interfaceClass.getName());</span><br><span class="line">                String result = (String) protocol.send(url, invocation);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HelloService helloService</span> = ProxyFactory.getProxy(HelloService.class);</span><br></pre></td></tr></table></figure><p>#AOP 熟读动态代理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#依赖注入方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;构造注入&lt;br&gt;有参数、或者无参构造器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;set注入&lt;br&gt;经常用到的注入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;延伸注入&lt;br&gt;c、p空间注入 但是需要schema/p | c&lt;/p&gt;
&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://www.nouyc.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>跟着小马哥理解spring核心</title>
    <link href="https://www.nouyc.com/2020/03/19/%E8%B7%9F%E7%9D%80%E5%B0%8F%E9%A9%AC%E5%93%A5%E7%90%86%E8%A7%A3spring%E6%A0%B8%E5%BF%83/"/>
    <id>https://www.nouyc.com/2020/03/19/跟着小马哥理解spring核心/</id>
    <published>2020-03-19T07:49:10.000Z</published>
    <updated>2020-03-23T12:50:31.373Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>spring是什么？</p><p>一句话，简化开发。Spring的理念，实现有技术更加容易使用。</p></li><li><p>spring当然是一个轻量级的框架，非入侵，倒入了用了就用了。</p></li></ol><ol start="3"><li>面向切面编程、控制反转。支持事物管理。</li></ol><ol start="4"><li>大杂汇！</li></ol><p>然后废话少说，总结上面几个特点就是spring是一个轻量级的控制反转（IOC）、面向切面编程的.</p><ol start="5"><li>缺点：配置十分繁琐。人称配置地狱。</li></ol><p>=======================</p><p>不扯了，直接推论IOC</p><h1 id="推论IOC"><a href="#推论IOC" class="headerlink" title="推论IOC"></a>推论IOC</h1><h2 id="first-day-新建项目"><a href="#first-day-新建项目" class="headerlink" title="first day 新建项目"></a>first day 新建项目</h2><p>UserDao</p><p>UserDaoImpl</p><p>UserService</p><p>UserServiceimpl</p><p>回到代码的上古时期，如果UserServiceimpl想调用UserDaoImpl的方法，怎么破…我清晰的记得我在大一的时候手动new了一个UserDaoImpl，然后各种摆弄。一时用一时爽，后几天发现一个问题….</p><h2 id="second-day-老师来需求了"><a href="#second-day-老师来需求了" class="headerlink" title="second day 老师来需求了"></a>second day 老师来需求了</h2><p>让我把替换下Dao的服务，换成mysql的服务，所以增加了一个UserDaoMysqlImpl，然后我要手动把之前每一个new的UserDaoImpl换成UserDaoMysqlImpl。不只是替换一次，一堆调用Dao的代码….</p><h2 id="third-day-想了一晚上"><a href="#third-day-想了一晚上" class="headerlink" title="third day 想了一晚上"></a>third day 想了一晚上</h2><p>想了一晚上的结果就是，为什么要每次都要改呢？直接把每次的调用实例传递进去就行啊。就比如说我告诉UserDaoImpl 我要调什么服务他去执行就行。怎么让他去执行呢？想了下按这样方法。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> <span class="type">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> print(<span class="keyword">String</span> name)&#123;</span><br><span class="line"><span class="keyword">return</span> userDao.print(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> userDao.print(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceimpl每次调用的时候都传递下自己的类型就ok了。</p><h2 id="自我怀疑，controller是服务调用方，根本不需要了解Dao的逻辑。"><a href="#自我怀疑，controller是服务调用方，根本不需要了解Dao的逻辑。" class="headerlink" title="自我怀疑，controller是服务调用方，根本不需要了解Dao的逻辑。"></a>自我怀疑，controller是服务调用方，根本不需要了解Dao的逻辑。</h2><p>这种方式从本质上解决了，不需要从代码上管理对象的创建。</p><h1 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h1><p>##本质其实就是一种思想， 而DI就是一种实现IOC的方式。个人认为控制反转就是获得依赖对象的方式反转了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;spring是什么？&lt;/p&gt;
&lt;p&gt;一句话，简化开发。Spring的理念，实现有技术更加容易使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;spring当然是一个轻量级的框架，非入侵，倒入了用了就用了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;3&quot;
      
    
    </summary>
    
    
      <category term="spring" scheme="https://www.nouyc.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>手撸一套dubbo（3）成熟篇 运用dubbo协议</title>
    <link href="https://www.nouyc.com/2020/03/18/%E6%89%8B%E6%92%B8%E4%B8%80%E5%A5%97dubbo%EF%BC%883%EF%BC%89%E6%88%90%E7%86%9F%E7%AF%87-%E8%BF%90%E7%94%A8dubbo%E5%8D%8F%E8%AE%AE/"/>
    <id>https://www.nouyc.com/2020/03/18/手撸一套dubbo（3）成熟篇-运用dubbo协议/</id>
    <published>2020-03-18T06:59:28.000Z</published>
    <updated>2020-03-19T07:48:21.910Z</updated>
    
    <content type="html"><![CDATA[<ol><li>废话不说，在上面基础上，我们把http协议改为dubbo协议吧。在protocol的dubbo目录下穿件netty的相关组件。</li></ol><p>NettyServer、NettyCient、NettyServerHandler、NettyClientHandler。</p><p>这里用到了netty的架构，没了解过netty架构的同学这里先照搬吧，多看几遍就有点门路了。</p><p>/NettyClient/<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个一件循环组</span></span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建客户端启动对象</span></span><br><span class="line">        <span class="comment">//客户端使用的是BootStrap</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置相关参数</span></span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(<span class="string">"client ok"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动客户端，连接服务器</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>/NettyClientHandler/<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通道就绪就会触发该方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Hello 哈哈哈"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息 "</span> +  buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器地址 "</span> +  ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>/NettyServer/<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2.Boss 只处理 accept 、 worker 负责业务处理</span></span><br><span class="line">        <span class="comment">//3.两个都是无限循环</span></span><br><span class="line">        EventLoopGroup  bossLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        EventLoopGroup  workerLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建造者模式</span></span><br><span class="line">        serverBootstrap.group(bossLoopGroup, workerLoopGroup)<span class="comment">//两个组</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)<span class="comment">//使用NioSocketChannel作为服务器的通道实现</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)<span class="comment">//设置线程队列得到连接个数</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="comment">//pipleline设置处理器</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        sc.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器准备好了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        <span class="comment">//启动服务器</span></span><br><span class="line">        ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">        channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(channelFuture.isSuccess())&#123;</span><br><span class="line">                    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>/NettyServerHandler/<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端的数据</span></span><br><span class="line">    <span class="comment">//1.ctx上下文、含有pipeline还有通道、地址</span></span><br><span class="line">    <span class="comment">//2.msg 客户端发送的数据，默认是object</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器读取线程："</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"server ctx ="</span> + ctx);</span><br><span class="line">        System.out.println(<span class="string">"看看channel 和pipeline 的关系"</span>);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        ChannelPipeline pipeline = ctx.pipeline();<span class="comment">//双向链表、入栈和出栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将msg转为byteBuffer</span></span><br><span class="line">        ByteBuf buf  = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"client 发送的消息："</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"client 地址："</span> + channel.remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//把数据写入缓冲并刷新</span></span><br><span class="line">        <span class="comment">//一般来讲，我们对发送的数据进行编码</span></span><br><span class="line">         ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello client"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改版下provider的启动类和consumer的proxy就可以切换 dubbo协议了.由httpServer切换为nettyserver。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 本地注册</span></span><br><span class="line">    <span class="comment">//&#123;服务名，实现类&#125;</span></span><br><span class="line">    LocalRegister.regiest(HelloService.<span class="keyword">class</span>.getName(), HelloServiceImol.<span class="keyword">class</span>);</span><br><span class="line">    <span class="comment">//2. 远程注册</span></span><br><span class="line">    <span class="comment">//&#123;服务名：list&lt;URL&gt;&#125;</span></span><br><span class="line">    URL url  = <span class="keyword">new</span> URL(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">    RemoteRegister.regiest(HelloService.<span class="keyword">class</span>.getName(), url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动tomcat，我们以tomcat为例子一步一步搞哈哈哈。</span></span><br><span class="line">    NettyServer server = <span class="keyword">new</span> NettyServer();</span><br><span class="line">    server.serverStart(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理切换httpClient 为 nettyClient<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static&lt;T&gt; T getProxy(<span class="class"><span class="keyword">Class</span> <span class="title">interfaceClass</span>)&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), <span class="keyword">new</span> <span class="class"><span class="keyword">Class</span>[]&#123;<span class="title">interfaceClass</span>&#125;, <span class="title">new</span> <span class="title">InvocationHandler</span>() &#123;</span></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> &#123;</span></span><br><span class="line">                NettyClient nettyClient = <span class="keyword">new</span> NettyClient();</span><br><span class="line">                Invocation invocation = <span class="keyword">new</span> Invocation(interfaceClass.getName(), <span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>), <span class="function"><span class="keyword">method</span>.<span class="title">getParameterTypes</span>(</span>), args);</span><br><span class="line"></span><br><span class="line">                URL url = RemoteRegister.random(interfaceClass.getName());</span><br><span class="line">                String result = nettyClient.send(url.getHostName(), url.getPort(), invocation);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再调一下，发现没，OK了！</p><p>再进行一次优化，我们发现切换下协议要改好几处代码，很坑爹，所以我们采用一套协议管理dubbo采用哪个协议可行么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer();</span><br><span class="line">        server.serverStart(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">send</span><span class="params">(URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyClient().send(url.getHostName(), url.getPort(), invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把NettyServer的启动类换成这个协议的start，还有Proxy的代理的Client换成这个协议类的send。就已经搞定了Dubbo的基本框架。至于采用哪个协议，我们不能一直改代码，也可以做成工厂动态处理，dubbo是根据URL的注册约定协议的，比如说dubbo:serivice protocol:dubbo ，这里为了简化我们可以配置到jvm系统配置里边。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Protocol getProtocol()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> protocol = System.getProperty(<span class="string">"protocol"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(protocol.isEmpty())&#123;</span><br><span class="line">            protocol = <span class="string">"http"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (protocol)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"http "</span>:<span class="type"></span></span><br><span class="line"><span class="type">                return new HttpProtocol</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"dubbo"</span>:<span class="type"></span></span><br><span class="line"><span class="type">                return new DubboProtocol</span>();</span><br><span class="line">            <span class="keyword">default</span>:<span class="type"></span></span><br><span class="line"><span class="type">                break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">HttpProtocol</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把用到protocol替换成工厂代理就可以了。这里就不再贴了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;废话不说，在上面基础上，我们把http协议改为dubbo协议吧。在protocol的dubbo目录下穿件netty的相关组件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;NettyServer、NettyCient、NettyServerHandler、NettyClient
      
    
    </summary>
    
    
      <category term="dubbo" scheme="https://www.nouyc.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>手撸一套dubbo（2） 进阶篇</title>
    <link href="https://www.nouyc.com/2020/03/18/%E6%89%8B%E6%92%B8%E4%B8%80%E5%A5%97dubbo-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>https://www.nouyc.com/2020/03/18/手撸一套dubbo-进阶篇/</id>
    <published>2020-03-18T03:02:41.000Z</published>
    <updated>2020-03-18T06:58:50.526Z</updated>
    
    <content type="html"><![CDATA[<ol><li>我们以上一篇为基础进行开发，做一个成型的dubbo的架构出来。</li></ol><p>我们总结下上一篇的问题，我们在consumer手动new出来了一个实现类，站在consumer的角度，这是不可能发生的事儿，我是透明化调用，不可能每次调用，都要手动去写他们的类名啊、方法名啊、参数列表等等。心累….</p><p>那能做一个工厂一样的代理类管理这些呢，是可以的。下面我们搞一个proxy。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; T getProxy(Class interfaceClass)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(interfaceClass.getClassLoader(), <span class="keyword">new</span> <span class="type">Class</span>[]&#123;interfaceClass&#125;, <span class="keyword">new</span> <span class="type">InvocationHandler</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把consumer中的执行请求移到代理类中。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; T getProxy(Class interfaceClass)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(interfaceClass.getClassLoader(), <span class="keyword">new</span> <span class="type">Class</span>[]&#123;interfaceClass&#125;, <span class="keyword">new</span> <span class="type">InvocationHandler</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                HttpClient httpClient = <span class="keyword">new</span> <span class="type">HttpClient</span>();</span><br><span class="line">                Invocation invocation = <span class="keyword">new</span> <span class="type">Invocation</span>(HelloService.class.getName(), <span class="string">"sayHello"</span>, <span class="keyword">new</span> <span class="type">Class</span>[]&#123;<span class="keyword">String</span>.class&#125;, <span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"耨宇辰"</span>&#125;);</span><br><span class="line">                <span class="keyword">String</span> result = httpClient.send(<span class="string">"localhost"</span>, <span class="number">8080</span>, invocation);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再看下，consumer的代码。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HelloService helloService = ProxyFactory.getProxy(HelloService.class);</span><br><span class="line">            String result = helloService.sayHello(<span class="string">"小白"</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"consumer 调用远程服务："</span>+ result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>是不是有点dubbo的影子了，然后我继续再优化架构,这时候我们发现ProxyFactory代理工厂中，有很多不通用的写法如下，</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invocation invocation = <span class="keyword">new</span> Invocation(HelloService.<span class="keyword">class</span>.getName(), <span class="string">"sayHello"</span>, <span class="keyword">new</span> Class[]&#123;<span class="built_in">String</span>.<span class="keyword">class</span>&#125;, <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="string">"耨宇辰"</span>&#125;);</span><br></pre></td></tr></table></figure><p>存在硬编码的操作，所以我们优化下这里。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invocation invocation = <span class="keyword">new</span> Invocation(interfaceClass.getName(), <span class="function"><span class="keyword">method</span>.<span class="title">getName</span><span class="params">()</span>, <span class="title">method</span>.<span class="title">getParameterTypes</span><span class="params">()</span>, <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><ol start="3"><li>因为我们是请求远程服务，这里我们直连，也不是通用的。改吧</li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> result = httpClient.<span class="built_in">send</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>, invocation)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>优化为如下，我们从远程注册中心拿到我们所需要的服务器地址和端口</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">URL url</span> = (URL) RemoteRegister.get(interfaceClass.getName());</span><br><span class="line"><span class="attribute">String result</span> = httpClient.send(url.getHostName(), url.getPort(), invocation);</span><br></pre></td></tr></table></figure><p>但是又存在多台服务器一起等待服务，所以这里我们加一个负载均衡。这里说下负载均衡通用算法有多种，随机轮询、权重、最短活跃时间。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL <span class="built_in">url</span> = RemoteRegister.random(interfaceClass.getName());</span><br><span class="line"><span class="built_in">String</span> result = httpClient.send(<span class="built_in">url</span>.getHostName(), <span class="built_in">url</span>.getPort(), invocation);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>最终我们的代理工厂完成,达到通用。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static&lt;T&gt; T getProxy(<span class="class"><span class="keyword">Class</span> <span class="title">interfaceClass</span>)&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), <span class="keyword">new</span> <span class="class"><span class="keyword">Class</span>[]&#123;<span class="title">interfaceClass</span>&#125;, <span class="title">new</span> <span class="title">InvocationHandler</span>() &#123;</span></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> &#123;</span></span><br><span class="line">                HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">                Invocation invocation = <span class="keyword">new</span> Invocation(interfaceClass.getName(), <span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>), <span class="function"><span class="keyword">method</span>.<span class="title">getParameterTypes</span>(</span>), args);</span><br><span class="line"></span><br><span class="line">                URL url = RemoteRegister.random(interfaceClass.getName());</span><br><span class="line">                String result = httpClient.send(url.getHostName(), url.getPort(), invocation);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有一个坑啊，你们自己撸下代码会报错。原因可以留言聊下。这里面来说，只能算是http协议的远程调用，dubbo协议的我们接下来搞定。dubbo协议底层使用的是netty。http底层使用的是tomcat。这块我们需要变一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;我们以上一篇为基础进行开发，做一个成型的dubbo的架构出来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们总结下上一篇的问题，我们在consumer手动new出来了一个实现类，站在consumer的角度，这是不可能发生的事儿，我是透明化调用，不可能每次调用，都要手动去写他
      
    
    </summary>
    
    
      <category term="dubbo" scheme="https://www.nouyc.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>手撸一套模拟dubbo</title>
    <link href="https://www.nouyc.com/2020/03/17/%E6%89%8B%E6%92%B8%E4%B8%80%E5%A5%97%E6%A8%A1%E6%8B%9Fdubbo/"/>
    <id>https://www.nouyc.com/2020/03/17/手撸一套模拟dubbo/</id>
    <published>2020-03-17T06:49:53.000Z</published>
    <updated>2020-03-18T03:06:19.235Z</updated>
    
    <content type="html"><![CDATA[<p>今天回顾下从一个http服务调用请求，怎么转变为一个负载均衡的rpc。</p><p>我们先来看下，解下来要搞定的包。</p><p><img src="/2020/03/17/手撸一套模拟dubbo/手撸dubbo.png" alt></p><ol><li><p>我们先搞定provider的启动类吧，实现一个 say 方法。作为我们一个预备调用service。</p><pre><code>//1. 本地注册//2. 远程注册 //3. 启动tomcat，我们以tomcat为例子一步一步搞哈哈哈。</code></pre><p>注意我们看下tomcat的结构，我们模拟一个httpserver出来。</p></li></ol><p><img src="/2020/03/17/手撸一套模拟dubbo/tomcat xml.png" alt></p><ol start="2"><li>模拟tomcat，直接粘代码了</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServer &#123;</span><br><span class="line"></span><br><span class="line">    public void start(String hostName, Integer port)&#123;</span><br><span class="line"></span><br><span class="line">        Tomcat tomcat = new Tomcat()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        Server server = tomcat.getServer()<span class="comment">;</span></span><br><span class="line">        Service service = server.findService(<span class="string">"Tomcat"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        Connector connector = new Connector()<span class="comment">;</span></span><br><span class="line">        connector.setPort(port)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        Engine engine = new StandardEngine()<span class="comment">;</span></span><br><span class="line">        engine.setDefaultHost(hostName)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        StandardHost standardHost = new StandardHost()<span class="comment">;</span></span><br><span class="line">        standardHost.setName(hostName)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        String contextPath = <span class="string">""</span><span class="comment">;</span></span><br><span class="line">        StandardContext <span class="built_in">context</span> = new StandardContext()<span class="comment">;</span></span><br><span class="line">        <span class="built_in">context</span>.setPath(contextPath)<span class="comment">;</span></span><br><span class="line">        <span class="built_in">context</span>.<span class="keyword">addLifecycleListener(new </span>Tomcat.FixContextListener())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        standardHost.<span class="keyword">addChild(context);</span></span><br><span class="line"><span class="keyword"> </span>       engine.<span class="keyword">addChild(standardHost);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       service.<span class="keyword">addConnector(connector);</span></span><br><span class="line"><span class="keyword"> </span>       service.setContainer(engine)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tomcat.<span class="keyword">addServlet(contextPath, </span><span class="string">"dispatcher"</span>, new <span class="keyword">DispatcherServlet());</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">context</span>.<span class="keyword">addServletMappingDecoded("/*", </span><span class="string">"dispatcher"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            tomcat.start()<span class="comment">;</span></span><br><span class="line">            tomcat.getServer().await()<span class="comment">;</span></span><br><span class="line">        &#125; catch ( LifecycleException e ) &#123;</span><br><span class="line">            e.printStackTrace()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用代码模拟一个tomcat启动server完成，但是mvc玩的比较6的同学这里注意到了，分发器dispatcher和映射handler还没有做。下面补充完整。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void service(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">HttpServletHandler</span>().handler(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServletHandler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理请求和返回结果</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要纠结简单哈，主要看逻辑</p><ol start="3"><li>tomcat搞完后，我们看下provider中的本地注册。</li></ol><p>我们搞一个注册本地类，其实就是一个map</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class LocalRegister &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span> , Class&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> regiest(<span class="keyword">String</span> intefaceName, Class impClass)&#123; <span class="built_in">map</span>.<span class="built_in">put</span>(intefaceName, impClass);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class <span class="built_in">get</span>(<span class="keyword">String</span> intefaceName)&#123; <span class="built_in">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(intefaceName);&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的provider 的代码看下,很简单<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 本地注册</span></span><br><span class="line">    <span class="comment">//&#123;服务名，实现类&#125;</span></span><br><span class="line">    LocalRegister.regiest(HelloService.class.getName(), HelloServiceImol.class);</span><br><span class="line">    <span class="comment">//2. 远程注册</span></span><br><span class="line">    <span class="comment">//&#123;服务名：list&lt;URL&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动tomcat，我们以tomcat为例子一步一步搞哈哈哈。</span></span><br><span class="line">    HttpServer <span class="keyword">server</span> = <span class="keyword">new</span> HttpServer();</span><br><span class="line">    <span class="keyword">server</span>.start(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们开始搞远程注册，因为有了远程，所以涉及网络通信，第一要想到有URL链接才可以。所以我们开始搞一个URL代理类。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class URL &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String hostName;</span><br><span class="line"></span><br><span class="line">    private Integer port;</span><br><span class="line"></span><br><span class="line">    public URL(String hostName, Integer port) &#123;</span><br><span class="line">        this.hostName = hostName;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getHostName() &#123;</span><br><span class="line">        return hostName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHostName(String hostName) &#123;</span><br><span class="line">        this.hostName = hostName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程注册代码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class RemoteRegister &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span> , List&lt;URL&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> regiest(<span class="keyword">String</span> intefaceName, URL url)&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;URL&gt; list = Collections.singletonList(url);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(intefaceName, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="built_in">get</span>(<span class="keyword">String</span> intefaceName)&#123; <span class="built_in">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(intefaceName);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个list<url>,为什么换成list呢，突破思维！因为远程的服务是多台。就是分布式服务！<br>然后我们再看下provider的运程注册<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 本地注册</span></span><br><span class="line">    <span class="comment">//&#123;服务名，实现类&#125;</span></span><br><span class="line">    LocalRegister.regiest(HelloService.<span class="keyword">class</span>.getName(), HelloServiceImol.<span class="keyword">class</span>);</span><br><span class="line">    <span class="comment">//2. 远程注册</span></span><br><span class="line">    <span class="comment">//&#123;服务名：list&lt;URL&gt;&#125;</span></span><br><span class="line">    URL url  = <span class="keyword">new</span> URL(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">    RemoteRegister.regiest(HelloService.<span class="keyword">class</span>.getName(), url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动tomcat，我们以tomcat为例子一步一步搞哈哈哈。</span></span><br><span class="line">    HttpServer server = <span class="keyword">new</span> HttpServer();</span><br><span class="line">    server.start(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></url></p><p>掌声！</p><p>今天写到了这了，明天3-18继续加油！！！搞定consumer我们就可以通信了。</p><ol start="4"><li>ok，我们看下consumer的调用代码，其实创建链接不用说了，最主要的是在双端怎么共同一个对象呢？<br>新建一个Invocation类。</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> interfaceName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> methodName;</span><br><span class="line">    <span class="keyword">private</span> Class[] paramType;</span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们回头再看consumer的源码。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpClient httpClient = <span class="keyword">new</span> <span class="type">HttpClient</span>();</span><br><span class="line">            Invocation invocation = <span class="keyword">new</span> <span class="type">Invocation</span>(HelloService.class.getName(), <span class="string">"sayHello"</span>, <span class="keyword">new</span><span class="type"></span></span><br><span class="line"><span class="type"></span>            Class[]&#123;<span class="keyword">String</span>.class&#125;, <span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"耨宇辰"</span>&#125;);</span><br><span class="line">            <span class="keyword">String</span> result = httpClient.send(<span class="string">"localhost"</span>, <span class="number">8080</span>, invocation);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( MalformedURLException e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>第一版最原生的远程服务调用就搞定了，启动provider server、启动 consumer。done。</li></ol><p><img src="/2020/03/17/手撸一套模拟dubbo/结果.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天回顾下从一个http服务调用请求，怎么转变为一个负载均衡的rpc。&lt;/p&gt;
&lt;p&gt;我们先来看下，解下来要搞定的包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/03/17/手撸一套模拟dubbo/手撸dubbo.png&quot; alt&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们
      
    
    </summary>
    
    
      <category term="dubbo" scheme="https://www.nouyc.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>HBase技术分享</title>
    <link href="https://www.nouyc.com/2019/10/14/HBase%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    <id>https://www.nouyc.com/2019/10/14/HBase技术分享/</id>
    <published>2019-10-14T01:56:51.000Z</published>
    <updated>2019-10-15T09:36:43.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HBase的定义"><a href="#HBase的定义" class="headerlink" title="HBase的定义"></a>HBase的定义</h2><p>  HBase是一种分布式、可扩展、支持海量数据存储的NoSql数据库。</p><h2 id="HBase的数据模型"><a href="#HBase的数据模型" class="headerlink" title="HBase的数据模型"></a>HBase的数据模型</h2><p>  逻辑上，HBase的数据模型同关系型数据库很类似，数据存储在一张表中，有行有列。但从HBase的底层物理存储结构（k-v）来看，HBase更像是一个多维度的Map。</p><h2 id="HBase逻辑结构"><a href="#HBase逻辑结构" class="headerlink" title="HBase逻辑结构"></a>HBase逻辑结构</h2><p><img src="/2019/10/14/HBase技术分享/HBase逻辑结构.png" alt></p><h2 id="HBase物理存储结构"><a href="#HBase物理存储结构" class="headerlink" title="HBase物理存储结构"></a>HBase物理存储结构</h2><p><img src="/2019/10/14/HBase技术分享/HBase物理存储结构.png" alt></p><h2 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h2><ol><li><p>Name Space</p><p>命名空间，类似于关系型数据库的DataBase的概念，每个命名空间下有多个表。HBase自带两个命名空间，分别是hbase和default。hbase中存放的是hbase自带的表。default表示用户默认的使用空间。</p></li><li><p>Region</p><p>类似于关系型数据库的表概念。不同的是，HBase在定义表的时候只需要声明列族即可，不需要声明具体的列。这意味着，在往HBase写入数据时，字段可以动态、按需指定。因此和关系型数据库相比，HBase能轻松应对字段变更的场景。</p></li><li><p>Row</p><p>HBase表中的每行数据都是由一个RowKe+多个Column组成，数据是按照RowKey的字典序存储的，并且查询数据时只能根据RowKey进行检索，所以RowKey的设计十分重要。</p></li><li><p>Column</p><p>HBase中的每个列都由Column Family（列族）和Column Qualifier（列限定符）进行限定，例如 imkf：chat_id, imkf: msg_id。建表时，只需指明列族，而列限定符无需预先定义。</p></li><li><p>Time Stamp</p><p>用于标识数据的不同版本（version），每条数据写入时，如果不指定时间戳，系统会自动为其加上该字段，其值为写入HBase的时间。</p></li><li><p>Cell</p><p>由 {rowkey, column Family: column Qualifier, time Stamp}唯一确定的单元。cell中的数据时没有类型的，全部是字节码形式存储。</p></li></ol><h2 id="HBase基本结构"><a href="#HBase基本结构" class="headerlink" title="HBase基本结构"></a>HBase基本结构</h2><p><img src="/2019/10/14/HBase技术分享/HBase基本结构.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HBase的定义&quot;&gt;&lt;a href=&quot;#HBase的定义&quot; class=&quot;headerlink&quot; title=&quot;HBase的定义&quot;&gt;&lt;/a&gt;HBase的定义&lt;/h2&gt;&lt;p&gt;  HBase是一种分布式、可扩展、支持海量数据存储的NoSql数据库。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="HBase" scheme="https://www.nouyc.com/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>B树、B+树、LSM树以及其典型应用场景</title>
    <link href="https://www.nouyc.com/2019/09/02/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81LSM%E6%A0%91%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://www.nouyc.com/2019/09/02/B树、B-树、LSM树以及其典型应用场景/</id>
    <published>2019-09-02T10:57:56.000Z</published>
    <updated>2019-09-02T10:57:56.897Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HBase基本命令</title>
    <link href="https://www.nouyc.com/2019/08/22/hbase%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.nouyc.com/2019/08/22/hbase基本命令/</id>
    <published>2019-08-22T06:05:50.000Z</published>
    <updated>2019-08-22T07:22:29.419Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>进入hbase的shell<br> hbase提供了一个shell的终端给用户交互</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@hadoop3</span> conf]<span class="meta"># hbase shell</span></span><br></pre></td></tr></table></figure><p> 退出使用quit或者ctrl+c<br> 需要关闭hadoop的安全模式不然进行一些操作，比如scan会卡住<br> 进入到hadoop的bin目录下<br> 在启动hbase之前</p></li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@hadoop3</span> conf]<span class="meta"># hadoop dfsadmin -safemode leave</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建表</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create ‘表名’,’列族<span class="number">1</span>’,’列族<span class="number">2</span>’,…’列族n’</span><br></pre></td></tr></table></figure></li><li><p>查看所有表</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span></span><br></pre></td></tr></table></figure></li><li><p>描述表</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe <span class="string">'user'</span></span><br><span class="line">Table user is ENABLED                                                                                                                                                            </span><br><span class="line">COLUMN FAMILIES DESCRIPTION                                                                                                                                                       </span><br><span class="line">&#123;NAME =&gt; <span class="string">'info1'</span>, DATA_BLOCK_ENCODING =&gt; <span class="string">'NONE'</span>, BLOOMFILTER =&gt; <span class="string">'ROW'</span>, REPLICATION_SCOPE =&gt; <span class="string">'0'</span>, VERSIONS =&gt; <span class="string">'1'</span>, COMPRESSION =&gt; <span class="string">'NONE'</span>, MIN_VERSIONS =&gt; <span class="string">'0'</span>, TTL =&gt; <span class="string">'FOREVER'</span>, KE</span><br><span class="line">EP_DELETED_CELLS =&gt; <span class="string">'FALSE'</span>, BLOCKSIZE =&gt; <span class="string">'65536'</span>, IN_MEMORY =&gt; <span class="string">'false'</span>, BLOCKCACHE =&gt; <span class="string">'true'</span>&#125;                                                                                    </span><br><span class="line">&#123;NAME =&gt; <span class="string">'info2'</span>, DATA_BLOCK_ENCODING =&gt; <span class="string">'NONE'</span>, BLOOMFILTER =&gt; <span class="string">'ROW'</span>, REPLICATION_SCOPE =&gt; <span class="string">'0'</span>, VERSIONS =&gt; <span class="string">'1'</span>, COMPRESSION =&gt; <span class="string">'NONE'</span>, MIN_VERSIONS =&gt; <span class="string">'0'</span>, TTL =&gt; <span class="string">'FOREVER'</span>, KE</span><br><span class="line">EP_DELETED_CELLS =&gt; <span class="string">'FALSE'</span>, BLOCKSIZE =&gt; <span class="string">'65536'</span>, IN_MEMORY =&gt; <span class="string">'false'</span>, BLOCKCACHE =&gt; <span class="string">'true'</span>&#125;                                                                                    </span><br><span class="line">2 row(s) in 0.0790 seconds</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">033</span>:<span class="number">0</span>&gt; disable <span class="string">'user'</span></span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.4110</span> seconds</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">034</span>:<span class="number">0</span>&gt; drop <span class="string">'user'</span></span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0.2330</span> seconds</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">035</span>:<span class="number">0</span>&gt; list</span><br><span class="line">TABLE                                                                                                                                                                             </span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0.0450</span> seconds</span><br></pre></td></tr></table></figure></li><li><p>判断表是否存在</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">040</span>:<span class="number">0</span>&gt; exists <span class="string">'user'</span></span><br><span class="line">Table user does exist                                                                                                                                                             </span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0.0980</span> seconds</span><br></pre></td></tr></table></figure></li><li><p>向表中添加数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">041</span>:<span class="number">0</span>&gt; put <span class="string">'user'</span>,<span class="string">'1234'</span>,<span class="string">'info1:name'</span>,<span class="string">'zhangsan'</span></span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">0.1310</span> seconds</span><br></pre></td></tr></table></figure><p> hbase没有直接修改操作，但是可以覆盖，只要rowkey跟列族列名一致就会覆盖<br> 比如这里要修改上面插入数据的info:name为’eve’</p></li><li><p>扫描整个表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">043</span>:<span class="number">0</span>&gt; scan <span class="string">'user'</span></span><br></pre></td></tr></table></figure></li><li><p>查询记录数</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main)<span class="symbol">:066</span><span class="symbol">:0</span>&gt; <span class="built_in">count</span> 'user'</span><br><span class="line"><span class="number">2</span> <span class="built_in">row</span>(s) in <span class="number">0.0340</span> seconds</span><br><span class="line"></span><br><span class="line">=&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):<span class="number">067</span>:<span class="number">0</span>&gt; <span class="built_in">get</span> <span class="string">'user'</span>,<span class="string">'1234'</span></span><br><span class="line">COLUMN                                CELL                                                                                                      </span><br><span class="line"> info1:age                            timestamp=<span class="number">1547125476542</span>, <span class="built_in">value</span>=<span class="number">18</span>                                                                         </span><br><span class="line"> info1:name                           timestamp=<span class="number">1547125469727</span>, <span class="built_in">value</span>=eve                                                                        </span><br><span class="line"> info2:favor                          timestamp=<span class="number">1547125482454</span>, <span class="built_in">value</span>=eat                                                                        </span><br><span class="line"><span class="number">3</span> row(s) <span class="keyword">in</span> <span class="number">0.0330</span> <span class="built_in">seconds</span></span><br></pre></td></tr></table></figure></li><li><p>查询某一个列族</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):<span class="number">068</span>:<span class="number">0</span>&gt; <span class="built_in">get</span> <span class="string">'user'</span>,<span class="string">'1234'</span>,<span class="string">'info1'</span></span><br><span class="line">COLUMN                                CELL                                                                                                      </span><br><span class="line"> info1:age                            timestamp=<span class="number">1547125476542</span>, <span class="built_in">value</span>=<span class="number">18</span>                                                                         </span><br><span class="line"> info1:name                           timestamp=<span class="number">1547125469727</span>, <span class="built_in">value</span>=eve                                                                        </span><br><span class="line"><span class="number">2</span> row(s) <span class="keyword">in</span> <span class="number">0.0280</span> <span class="built_in">seconds</span></span><br></pre></td></tr></table></figure><p>查询某个时间戳版本<br>不知道时间戳<br>先将这一个列族修改为能选择三个版本的列族，可以随便选择查多少个版本，查的版本只要比存的版本少就行</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):<span class="number">069</span>:<span class="number">0</span>&gt; alter <span class="string">'user'</span> ,&#123;<span class="function"><span class="params">NAME</span>=&gt;</span><span class="string">'info1'</span>,<span class="function"><span class="params">VERSIONS</span>=&gt;</span><span class="number">3</span>&#125;</span><br><span class="line">hbase(main):<span class="number">070</span>:<span class="number">0</span>&gt; <span class="keyword">get</span> <span class="string">'user'</span>，<span class="string">'1234'</span>，&#123;<span class="function"><span class="params">COLUMN</span>=&gt;</span><span class="string">'info1:name'</span>,<span class="function"><span class="params">VERSIONS</span>=&gt;</span><span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>知道时间戳</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):<span class="number">071</span>:<span class="number">0</span>&gt; <span class="keyword">get</span> <span class="string">'user'</span>, <span class="string">'1234'</span>, &#123;<span class="function"><span class="params">COLUMN</span> =&gt;</span> <span class="string">'info1:name'</span>,<span class="function"><span class="params">TIMESTAMP</span> =&gt;</span> <span class="number">1538014481194</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除记录<br>删除列族下的某一列</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">071</span>:<span class="number">0</span>&gt; delete <span class="string">'user'</span>,<span class="string">'1234'</span>,<span class="string">'info1:name'</span></span><br></pre></td></tr></table></figure><p>删除某一列族</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">072</span>:<span class="number">0</span>&gt; delete <span class="string">'user'</span>,<span class="string">'1234'</span>,<span class="string">'info2'</span></span><br></pre></td></tr></table></figure><p>删除某一行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">073</span>:<span class="number">0</span>&gt; deleteall <span class="string">'user'</span>,<span class="string">'1234'</span></span><br></pre></td></tr></table></figure></li><li><p>清空表</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">074</span>:<span class="number">0</span>&gt; truncate <span class="string">'user'</span></span><br><span class="line">Truncating <span class="string">'user'</span> <span class="selector-tag">table</span> (it may take <span class="selector-tag">a</span> while):</span><br><span class="line"> - Disabling <span class="selector-tag">table</span>...</span><br><span class="line"> - Truncating <span class="selector-tag">table</span>...</span><br><span class="line"><span class="number">0</span> row(s) <span class="keyword">in</span> <span class="number">1.4540</span> seconds</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">075</span>:<span class="number">0</span>&gt; scan <span class="string">'user'</span></span><br><span class="line">ROW                                   COLUMN+CELL</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入hbase的shell&lt;br&gt; hbase提供了一个shell的终端给用户交互&lt;/p&gt;
&lt;figure class=&quot;highlight autoit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="hbase" scheme="https://www.nouyc.com/tags/hbase/"/>
    
  </entry>
  
  <entry>
    <title>Spring Aop实例@Aspect、@Before、@AfterReturning@Around 注解方式配置</title>
    <link href="https://www.nouyc.com/2019/08/19/%E5%A4%A7%E5%86%99%E7%9A%84Spring/"/>
    <id>https://www.nouyc.com/2019/08/19/大写的Spring/</id>
    <published>2019-08-19T03:27:14.000Z</published>
    <updated>2019-08-19T06:49:55.808Z</updated>
    
    <content type="html"><![CDATA[<p>用过spring框架进行开发的人，多多少少会使用过它的AOP功能，都知道有@Before、@Around和@After等advice。最近，为了实现项目中的输出日志和权限控制这两个需求，我也使用到了AOP功能。我使用到了@Before、@Around这两个advice。但在，使用过程中，却对它们的执行顺序并不清楚。为了弄清楚在不同情况下，这些advice到底是以怎么样的一个顺序进行执行的，我作了个测试，在此将其记录下来，以供以后查看。</p><p>前提<br>   对于AOP相关类(aspect、pointcut等)的概念，本文不作说明。<br>   对于如何让spring框架扫描到AOP，本文也不作说明。</p><h2 id="情况一-一个方法只被一个Aspect类拦截"><a href="#情况一-一个方法只被一个Aspect类拦截" class="headerlink" title="情况一: 一个方法只被一个Aspect类拦截"></a>情况一: 一个方法只被一个Aspect类拦截</h2><p>当一个方法只被一个Aspect拦截时，这个Aspect中的不同advice是按照怎样的顺序进行执行的呢？请看:</p><h2 id="添加-PointCut类"><a href="#添加-PointCut类" class="headerlink" title="添加 PointCut类"></a>添加 PointCut类</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="keyword">Pointcut</span>("@<span class="keyword">annotation</span>(<span class="keyword">com</span>.<span class="keyword">guazi</span>.<span class="keyword">gelada</span>.<span class="keyword">rest</span>.<span class="keyword">web</span>.<span class="keyword">aop</span>.<span class="keyword">RequestSysLog</span>)")</span><br><span class="line"><span class="keyword">public</span> void logPointCut() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加Aspect类"><a href="#添加Aspect类" class="headerlink" title="添加Aspect类"></a>添加Aspect类</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">printSysLog</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="comment">//请求方法</span></span><br><span class="line">        String methodName = signature.getName();</span><br><span class="line">        <span class="comment">//获取request</span></span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line"></span><br><span class="line">        LOG.info(<span class="string">"inner web accept request method = &#123;&#125; and paramName = &#123;&#125;, params = &#123;&#125;"</span>, methodName, signature.getParameterNames(), joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"around"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterReturning"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterThrowing"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="添加测试用Controller"><a href="#添加测试用Controller" class="headerlink" title="添加测试用Controller"></a>添加测试用Controller</h2><p>添加一个用于测试的controller，这个controller中只有一个方法，但是它会根据参数值的不同，会作出不同的处理：一种是正常返回一个对象，一种是抛出异常(因为我们要测试@AfterThrowing这个advice)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/aop"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTestController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.OK)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">test</span><span class="params">(@RequestParam <span class="keyword">boolean</span> throwException)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// case 1</span></span><br><span class="line">        <span class="keyword">if</span> (throwException) &#123;</span><br><span class="line">            System.out.println(<span class="string">"throw an exception"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TestException(<span class="string">"mock a server exception"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// case 2</span></span><br><span class="line">        System.out.println(<span class="string">"test OK"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result() &#123;&#123;</span><br><span class="line">            <span class="keyword">this</span>.setId(<span class="number">111</span>);</span><br><span class="line">            <span class="keyword">this</span>.setName(<span class="string">"mock a Result"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到输出结果<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">around </span><br><span class="line">before </span><br><span class="line"><span class="keyword">test </span>OK</span><br><span class="line">around2</span><br><span class="line">after</span><br><span class="line">afterReturning</span><br></pre></td></tr></table></figure></p><p>要是出现异常情况看下返回</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">around</span></span><br><span class="line"><span class="keyword">before</span> </span><br><span class="line">throw an exception</span><br><span class="line"><span class="keyword">after</span> </span><br><span class="line">afterThrowing</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在一个方法只被一个aspect类拦截时，aspect类内部的 advice 将按照以下的顺序进行执行：</p><p>正常执行顺序<br><img src="/2019/08/19/大写的Spring/aop请求1.jpg" alt></p><p>异常执行顺序<br><img src="/2019/08/19/大写的Spring/aop请求2.jpg" alt></p><h2 id="如果有多个aspect呢？"><a href="#如果有多个aspect呢？" class="headerlink" title="如果有多个aspect呢？"></a>如果有多个aspect呢？</h2><p>多个aspect进行pointCut，顺序不定，可以用@order指定执行顺序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用过spring框架进行开发的人，多多少少会使用过它的AOP功能，都知道有@Before、@Around和@After等advice。最近，为了实现项目中的输出日志和权限控制这两个需求，我也使用到了AOP功能。我使用到了@Before、@Around这两个advice。但在
      
    
    </summary>
    
      <category term="spring" scheme="https://www.nouyc.com/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.nouyc.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>HBase分享问题总结</title>
    <link href="https://www.nouyc.com/2019/07/19/HBase%E5%88%86%E4%BA%AB%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://www.nouyc.com/2019/07/19/HBase分享问题总结/</id>
    <published>2019-07-19T10:53:48.000Z</published>
    <updated>2019-08-22T13:24:55.740Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>HBsae是按字典序列写入？</p></li><li><p>HBase为什么这么快。</p></li><li><p>主键的所有属性？</p></li><li><p>为什么提前region分区，等待他自动分裂也可以？</p></li><li><p>HMaster的主从切换?</p></li></ol><p>问题为什么这么快？</p><h2 id="写入快"><a href="#写入快" class="headerlink" title="写入快"></a>写入快</h2><ol><li>写入内存、顺序写入。 </li><li>删除更新功能：删除数据不是进行实质上的删除，也就是磁盘上仍然存在此条数据。只不过是对删除的数据打上了墓碑标记。利用墓碑标记，读数据会忽略此条数据。当进行小文件合并时，才会进行实质上删除。</li><li>剩下的合并、flush、compact都由region进行搞</li></ol><h2 id="读取快"><a href="#读取快" class="headerlink" title="读取快"></a>读取快</h2><p>B+树的应用场景：主要用在传统的行数据库中，因为查询速度快。但是如有有大量的数据需要查询时就暴露出其弊端。</p><p>LSM树的应用场景：Hbase就是使用了LSM树。</p><p>主要的实现方式：写数据时，第一步，写到预写日志中，目的是防止数据在写入时丢失；</p><p>　　第二步，将数据放入到内存中。</p><p>　　第三步，当内存的大小超过指定值，会把内存中的数据写入到磁盘上。</p><p>需要注意一个关键点：磁盘的数据是有序的，这是利用预写日志和内存把随机写数据进行排序后写入，因此也能保证稳定的数据插入速率。</p><p>LSM的优点：能快速进行数据的合并和拆分。</p><h2 id="负责架构"><a href="#负责架构" class="headerlink" title="负责架构"></a>负责架构</h2><p><img src="/2019/07/19/HBase分享问题总结/hbase结构.png" alt></p><p>一个RS上只有一个HLog</p><ol><li><p>client职责：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第 <span class="number">1</span> 步：Client 请求 ZooKeeper 获取<span class="selector-class">.META</span>.所在的 RegionServer 的地址。</span><br><span class="line"><span class="selector-class">.META</span>.：记录了用户所有表拆分出来的的 Region 映射信息，<span class="selector-class">.META</span>.可以有多个 Regoin</span><br><span class="line">第 <span class="number">2</span> 步：Client 请求<span class="selector-class">.META</span>.所在的 RegionServer 获取访问数据所在的 RegionServer 地址，Client</span><br><span class="line">会将<span class="selector-class">.META</span>.的相关信息 cache 下来，以便下一次快速访问。</span><br><span class="line">第 <span class="number">3</span> 步：Client 请求数据所在的 RegionServer，获取所需要的数据</span><br><span class="line"></span><br><span class="line">在这里会有一个问题，那就是 Client 会缓存<span class="selector-class">.META</span>.的数据，用来加快访问，既然有缓存，那它什么时候更新？</span><br><span class="line">如果<span class="selector-class">.META</span>.更新了，比如 Region1不在RerverServer2上了，被转移到了RerverServer3上。Client 的缓存没有更新会有什么情况呢？</span><br><span class="line"></span><br><span class="line">其实，Client 的元数据缓存不更新，当<span class="selector-class">.META</span>.的数据发生更新。如上面的例子，由于 Region1的位置发生了变化，Client 再次根据缓存去访问的时候，会出现错误，</span><br><span class="line">当出现异常达到重试次数后就会去<span class="selector-class">.META</span>.所在的 RegionServer 获取最新的数据，如果<span class="selector-class">.META</span>.所在的 RegionServer也变了，Client 就会去 ZooKeeper 上获取<span class="selector-class">.META</span>.所在的 RegionServer 的最新地址</span><br><span class="line"></span><br><span class="line">其实这也是region的一种寻址方式！！！(client要对某一行数据做读写的过程)</span><br></pre></td></tr></table></figure></li><li><p>ZooKeeper的职责：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、ZooKeeper为HBase提供 Failover 机制，选举 <span class="literal">Master</span>，避免单点 <span class="keyword">Master</span> <span class="title">单点故障问题</span></span><br><span class="line"><span class="title">2</span>、存储所有 Region 的寻址入口：.<span class="keyword">META</span>.表在哪台服务器上，.<span class="keyword">META</span>.这张表的位置信息</span><br><span class="line"><span class="number">3</span>、实时监控 RegionServer 的状态，将 RegionServer 的上线和下线信息实时通知给 <span class="literal">Master</span></span><br><span class="line"><span class="number">4</span>、存储HBase的Schema，包括有哪些Table，每个Table有哪些Column Family</span><br></pre></td></tr></table></figure></li><li><p>Master职责：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、为 RegionServer 分配 Region</span><br><span class="line"><span class="number">2</span>、负责 RegionServer 的负载均衡</span><br><span class="line"><span class="number">3</span>、发现失效的 RegionServer 并重新分配其上的 Region</span><br><span class="line"><span class="number">4</span>、HDFS 上的垃圾文件（HBase）回收</span><br><span class="line"><span class="number">5</span>、处理 Schema 更新请求（表的创建，删除，修改，列簇的增加等等）</span><br></pre></td></tr></table></figure></li><li><p>RegionServer的职责：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、RegionServer 维护 Master 分配给它的 Region，处理对这些 Region 的 IO 请求</span><br><span class="line"><span class="number">2</span>、负责和底层的文件系统 HDFS 的交互，存储数据到 HDFS</span><br><span class="line"><span class="number">3</span>、负责 Store 中的 HFile 的合并工作</span><br><span class="line"><span class="number">4</span>、RegionServer 负责 Split 在运行过程中变得过大的 Region，负责 Compact 操作</span><br></pre></td></tr></table></figure></li></ol><p>以上可以看到，client 访问 HBase 上数据的过程并不需要 Master 参与（寻址访问 ZooKeeper 和<br>RegioneServer，数据读写访问 RegioneServer），Master 仅仅维护Table 和 Region 的元数据<br>信息，负载很低。<br>.META. 存的是所有的 Region 的位置信息，那么 RegioneServer 当中 Region 在进行分裂之后<br>的新产生的 Region，是由 Master 来决定发到哪个 RegioneServer，这就意味着，只有 Master<br>知道 new Region 的位置信息，所以，由 Master 来管理.META.这个表当中的数据的 CRUD</p><blockquote><p>在没有 Region 分裂的情况，Master 宕机一段时间是可以忍受的。</p></blockquote><h2 id="物理架构"><a href="#物理架构" class="headerlink" title="物理架构"></a>物理架构</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、Table 中的所有行都按照 RowKey 的字典序排列。</span><br><span class="line">2、Table 在行的方向上分割为多个 HRegion。</span><br><span class="line">3、HRegion 按大小分割的(默认 10G)，每个表一开始只有一个 HRegion，随着数据不断插入表，HRegion 不断增大，当增大到一个阀值的时候，HRegion 就会等分会两个新的 HRegion。 当表中的行不断增多，就会有越来越多的 HRegion。 </span><br><span class="line">4、HRegion 是 Hbase 中分布式存储和负载均衡的最小单元。最小单元就表示不同的 HRegion可以分布在不同的 HRegionServer 上。但一个 HRegion 是不会拆分到多个<span class="built_in"> server </span>上的(也就是没有hdfs中block的副本功能)。</span><br><span class="line">5、HRegion 虽然是负载均衡的最小单元，但并不是物理存储的最小单元。事实上，HRegion由一个或者多个 Store 组成，每个 Store 保存一个 Column Family。每个 Strore 又由一个MemStore 和 0 至多个 StoreFile 组成</span><br><span class="line">   写操作先写入memstore中，当memstore达到一定的阈值时，HRegionServer会启动flushcache进程写入到storefile中，每次写入形成单独的一个hfile，</span><br><span class="line">   当storefile达到一定的阈值时，会把当前的region分裂成两个region，并由master把新分裂出来的region分配到相应的HRegionServer服务器上，实现负载均衡。</span><br><span class="line">   客户端在检索数据时，先在memstore中查找，没有再到storefile中查找。</span><br><span class="line">6、每个 Region<span class="built_in"> Server </span>维护一个 HLog，而不是每个 Region 一个。这样不同 region(来自不同 table)的日志会混在一起，这样做的目的是不断追加单个文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此可以提高对 table 的写性能。</span><br><span class="line">   带来的麻烦是，如果一台 region server下线，为了恢复其上的 Region，需要将 RegionServer 上的 log 进行拆分，然后分发到其它RegionServer 上进行恢复</span><br></pre></td></tr></table></figure><h2 id="读写过程："><a href="#读写过程：" class="headerlink" title="读写过程："></a>读写过程：</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">读请求过程：</span><br><span class="line"><span class="symbol">&lt;1&gt;</span>、client通过ZK找到.META.表所在的HRegionServer，client通过.META.表所在的HRegionServer找到所需数据的HRegionServer</span><br><span class="line"><span class="symbol">&lt;2&gt;</span>、然后到数据所在的HRegionServer上获取相关数据</span><br><span class="line"><span class="symbol">&lt;3&gt;</span>、HRegionServer 定位到目标数据所在的 Region，发出查询请求</span><br><span class="line"><span class="symbol">&lt;4&gt;</span>、Region 先在 Memstore 中查找，命中则返回</span><br><span class="line"><span class="symbol">&lt;5&gt;</span>、如果在 Memstore 中找不到，则在 Storefile 中扫描</span><br><span class="line">为了能快速的判断要查询的数据在不在这个 StoreFile 中，应用了 BloomFilter</span><br><span class="line"></span><br><span class="line">BloomFilter，布隆过滤器：迅速判断一个元素是不是在一个庞大的集合内，但是他有一个弱点：它有一定的误判率</span><br><span class="line">误判率：原本不存在与该集合的元素，布隆过滤器有可能会判断说它存在，但是，如果布隆过滤器，判断说某一个元素不存在该集合，那么该元素就一定不在该集合内</span><br><span class="line"></span><br><span class="line">写请求过程：</span><br><span class="line"><span class="symbol">&lt;1&gt;</span>、Client 先根据 RowKey 找到对应的 Region 所在的 RegionServer</span><br><span class="line"><span class="symbol">&lt;2&gt;</span>、Client 向 RegionServer 提交写请求</span><br><span class="line"><span class="symbol">&lt;3&gt;</span>、RegionServer 找到目标 Region</span><br><span class="line"><span class="symbol">&lt;4&gt;</span>、Region 检查数据是否与 Schema 一致</span><br><span class="line"><span class="symbol">&lt;5&gt;</span>、如果客户端没有指定版本，则获取当前系统时间作为数据版本</span><br><span class="line"><span class="symbol">&lt;6&gt;</span>、将更新写入 WAL Log</span><br><span class="line"><span class="symbol">&lt;7&gt;</span>、将更新写入 Memstore</span><br><span class="line"><span class="symbol">&lt;8&gt;</span>、判断 Memstore 的是否需要 flush 为 StoreFile 文件</span><br><span class="line">Hbase 在做数据插入操作时，首先要找到 RowKey 所对应的的 Region，怎么找到的？其实这个简单，因为.META.表存储了每张表每个 Region 的起始 RowKey 了。</span><br><span class="line"></span><br><span class="line">在实际生产中注意：在做海量数据的插入操作，应该避免出现递增 rowkey 的 <span class="keyword">put</span> 操作，</span><br><span class="line">如果 <span class="keyword">put</span> 操作的所有 RowKey 都是递增的，那么试想，当插入一部分数据的时候刚好进行分裂，那么之后的所有数据都开始往分裂后的第二个 Region 插入，就造成了数据热点现象</span><br></pre></td></tr></table></figure><p>数据在更新时首先写入 HLog(WAL Log)，再写入内存(MemStore)中，MemStore 中的数据是排<br>序的，当 MemStore 累计到一定阈值(默认是 128M)时，就会创建一个新的 MemStore，并且<br>将老的 MemStore 添加到 flush 队列，由单独的线程 flush 到磁盘上，成为一个 StoreFile。于<br>此同时，系统会在 ZooKeeper 中记录一个 redo point，表示这个时刻之前的变更已经持久化<br>了。当系统出现意外时，可能导致内存(MemStore)中的数据丢失，此时使用 HLog(WAL Log)<br>来恢复 checkpoint 之后的数据。</p><h2 id="Memstore-执行刷盘操作的的触发条件："><a href="#Memstore-执行刷盘操作的的触发条件：" class="headerlink" title="Memstore 执行刷盘操作的的触发条件："></a>Memstore 执行刷盘操作的的触发条件：</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt;、全局内存控制：当所有 memstore 占整个 heap 的最大比例的时候，会触发刷盘的操作。</span><br><span class="line">这个参数是hbase<span class="selector-class">.regionserver</span><span class="selector-class">.global</span><span class="selector-class">.memstore</span><span class="selector-class">.upperLimit</span>，默认为整个heap内存的<span class="number">40%</span>。</span><br><span class="line">这个全局的参数是控制内存整体的使用情况，但这并不意味着全局内存触发的刷盘操作会将所有的MemStore都进 行输盘，而是通过另外一个参数hbase<span class="selector-class">.regionserver</span><span class="selector-class">.global</span><span class="selector-class">.memstore</span><span class="selector-class">.lowerLimit</span> 来控制，默认是整个 heap 内存的 <span class="number">35%</span>。</span><br><span class="line">当flush 到所有 memstore 占整个 heap 内存的比率为 <span class="number">35%</span>的时候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的目的。</span><br><span class="line">&lt;<span class="number">2</span>&gt;、当 MemStore 的大小达到 hbase<span class="selector-class">.hregion</span><span class="selector-class">.memstore</span><span class="selector-class">.flush</span><span class="selector-class">.size</span> 大小的时候会触发刷盘，默认 <span class="number">128</span>M 大小。</span><br><span class="line">&lt;<span class="number">3</span>&gt;、前面说到 HLog 为了保证 HBase 数据的一致性，那么如果 HLog 太多的话，会导致故障恢复的时间太长，因此 HBase 会对 HLog 的最大个数做限制。</span><br><span class="line">当达到 Hlog 的最大个数的时候，会强制刷盘。这个参数是 hase<span class="selector-class">.regionserver</span><span class="selector-class">.max</span><span class="selector-class">.logs</span>，默认是 <span class="number">32</span> 个。</span><br><span class="line">HLog默认是在HRegionServer上一小时形成一个新的HLog，在memstore的数据flush到storefile后，也会把之前的的HLog删除，其实也就是尽量保证最新的HLog保留的是memstore中的log，已经flush的数据的log会在后面进行删除。</span><br><span class="line">&lt;<span class="number">4</span>&gt;、可以通过 HBase Shell 或者 Java API 手工触发 flush 的操作。</span><br></pre></td></tr></table></figure><h2 id="HBase-的三种默认的-Split-策略："><a href="#HBase-的三种默认的-Split-策略：" class="headerlink" title="HBase 的三种默认的 Split 策略："></a>HBase 的三种默认的 Split 策略：</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、ConstantSizeRegionSplitPolicy</span><br><span class="line"><span class="number">2</span>、IncreasingToUpperBoundRegionSplitPolicy</span><br><span class="line"><span class="number">3</span>、SteppingSplitPolicy</span><br></pre></td></tr></table></figure><p>StoreFile 是只读的，一旦创建后就不可以再修改。因此 HBase 的更新/修改其实是不断追加<br>的操作。当一个 Store 中的 StoreFile 达到一定的阈值后，就会进行一次合并(minor_compact,<br>major_compact)，将对同一个 key 的修改合并到一起，形成一个大的 StoreFile，当 StoreFile<br>的大小达到一定阈值后，又会对 StoreFile 进行 split，等分为两个 StoreFile。由于对表的更<br>新是不断追加的，compact 时，需要访问 Store 中全部的 StoreFile 和 MemStore，将他们按<br>rowkey 进行合并，由于 StoreFile 和 MemStore 都是经过排序的，并且 StoreFile 带有内存中<br>索引，合并的过程还是比较快。</p><h2 id="Minor-Compact-和-Major-Compact-的区别："><a href="#Minor-Compact-和-Major-Compact-的区别：" class="headerlink" title="Minor_Compact 和 Major_Compact 的区别："></a>Minor_Compact 和 Major_Compact 的区别：</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt;、Minor 操作只用来做部分文件的合并操作以及包括 minVersion=<span class="number">0</span> 并且设置 ttl 的过期版本清理，不做任何删除数据、多版本数据的清理工作。</span><br><span class="line">&lt;<span class="number">2</span>&gt;、Major 操作是对 Region 下的 HStore 下的所有 StoreFile 执行合并操作，最终的结果是整理合并出一个文件。</span><br></pre></td></tr></table></figure><p>HBase 只是增加数据，所有的更新和删除操作，都是在 Compact 阶段做的，所以用户写操作只需要进入到内存即可立即返回，从而保证 I/O 高性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;HBsae是按字典序列写入？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HBase为什么这么快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主键的所有属性？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么提前region分区，等待他自动分裂也可以？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="大数据" scheme="https://www.nouyc.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hbase" scheme="https://www.nouyc.com/tags/hbase/"/>
    
      <category term="HDFS" scheme="https://www.nouyc.com/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis扫盲</title>
    <link href="https://www.nouyc.com/2019/07/16/MyBatis%E6%89%AB%E7%9B%B2/"/>
    <id>https://www.nouyc.com/2019/07/16/MyBatis扫盲/</id>
    <published>2019-07-16T01:52:12.000Z</published>
    <updated>2019-07-16T02:00:26.892Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>什么是Mybatis？</p></li><li><p>Mybaits的优点？</p></li><li><p>MyBatis框架的缺点？</p></li><li><p>MyBatis框架适用场合？</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是Mybatis？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mybaits的优点？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MyBatis框架的缺点？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MyBatis框架适用场合？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://www.nouyc.com/categories/SpringBoot/"/>
    
    
      <category term="mysql" scheme="https://www.nouyc.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>深入理解HDFS</title>
    <link href="https://www.nouyc.com/2019/07/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HDFS/"/>
    <id>https://www.nouyc.com/2019/07/12/深入理解HDFS/</id>
    <published>2019-07-12T03:37:53.000Z</published>
    <updated>2019-07-12T08:31:21.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="胡思乱想"><a href="#胡思乱想" class="headerlink" title="胡思乱想"></a>胡思乱想</h2><p>HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。<br><img src="/2019/07/12/深入理解HDFS/nfs文件系统.png" alt="nfs文件系统"></p><h2 id="HDFS的小目标"><a href="#HDFS的小目标" class="headerlink" title="HDFS的小目标"></a>HDFS的小目标</h2><ol><li><p>设计目标</p><p>· 存储非常大的文件<br>· 采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理      模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次<br>· 运行于商业硬件上</p></li><li><p>HDFS不适合的应用类型</p><p>·低延时的数据访问<br>·大量小文件<br>·多方读写，需要任意的文件修改</p></li></ol><h2 id="HDFS几个核心概念"><a href="#HDFS几个核心概念" class="headerlink" title="HDFS几个核心概念"></a>HDFS几个核心概念</h2><ol><li><p>Blocks</p><p> 物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。</p><p> HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。</p><p> HDFS的Block为什么这么大？<br> 是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。<br> 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。</p><p> Block抽象的好处<br>   Block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。<br>   Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。</p></li><li><p>Namenode &amp; Datanode</p><p>  整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。</p><p>  (1) Namenode</p><blockquote><p>Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：namespcae image/edit log<br>但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。<br>在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： </p></blockquote><p>  (2) 备份持久化元数据</p><blockquote><p>将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。</p></blockquote><p>  (3) Secondary Namenode </p><blockquote><p>Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。<br>Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。<br>在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。</p></blockquote><p>  (4) Datanode</p><blockquote><p>数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。</p></blockquote></li><li><p>Block Caching<br> DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。<br> 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。<br> 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。</p></li><li><p>HDFS Federation<br> 我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。<br> 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。<br> 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。</p></li></ol><ol start="5"><li><p>HDFS HA(High Availability高可用性)<br> 在HDFS集群中，NameNode依然是单点故障（SPOF: Single Point Of Failure）。元数据同时写到多个文件系统以及Second NameNode定期checkpoint有利于保护数据丢失，但是并不能提高可用性。<br> 这是因为NameNode是唯一一个对文件元数据和file-block映射负责的地方， 当它挂了之后，包括MapReduce在内的作业都无法进行读写。</p><p> 当NameNode故障时，常规的做法是使用元数据备份重新启动一个NameNode。元数据备份可能来源于：</p><p> ·多文件系统写入中的备份<br> Second NameNode的检查点文件<br> 启动新的Namenode之后，需要重新配置客户端和DataNode的NameNode信息。另外重启耗时一般比较久，稍具规模的集群重启经常需要几十分钟甚至数小时，造成重启耗时的原因大致有：<br> 1） 元数据镜像文件载入到内存耗时较长。<br> 2） 需要重放edit log<br> 3） 需要收到来自DataNode的状态报告并且满足条件后才能离开安全模式提供写服务。</p></li></ol><h2 id="Hadoop的HA方案"><a href="#Hadoop的HA方案" class="headerlink" title="Hadoop的HA方案"></a>Hadoop的HA方案</h2><ol><li>主备需共享edit log存储</li><li>DataNode需要同时往主备发送Block Report</li><li>客户端需要配置failover模式（失效备援模式，对用户透明） </li><li><p>Standby替代Secondary NameNode</p><p> 采用HA的HDFS集群配置两个NameNode，分别处于Active和Standby状态。当Active NameNode故障之后，Standby接过责任继续提供服务，用户没有明显的中断感觉。一般耗时在几十秒到数分钟。<br> HA涉及到的主要实现逻辑有</p><p>  ·主备需共享edit log存储。 </p><blockquote><p>主NameNode和待命的NameNode共享一份edit log，当主备切换时，Standby通过回放edit log同步数据。 </p></blockquote><p>  ·共享存储通常有2种选择</p><blockquote><p>NFS：传统的网络文件系统<br>QJM：quorum journal manager<br>QJM是专门为HDFS的HA实现而设计的，用来提供高可用的edit log。QJM运行一组journal node，edit log必须写到大部分的journal nodes。通常使用3个节点，因此允许一个节点失败，类似ZooKeeper。注意QJM没有使用ZK，虽然HDFS HA的确使用了ZK来选举主Namenode。一般推荐使用QJM。</p></blockquote><p>  ·DataNode需要同时往主备发送Block Report </p><blockquote><p>因为Block映射数据存储在内存中（不是在磁盘上），为了在Active NameNode挂掉之后，新的NameNode能够快速启动，不需要等待来自Datanode的Block Report，DataNode需要同时向主备两个NameNode发送Block Report。</p></blockquote><p>  ·客户端需要配置failover模式（失效备援模式，对用户透明） </p><blockquote><p>Namenode的切换对客户端来说是无感知的，通过客户端库来实现。客户端在配置文件中使用的HDFS URI是逻辑路径，映射到一对Namenode地址。客户端会不断尝试每一个Namenode地址直到成功。</p></blockquote><p>  ·Standby替代Secondary NameNode </p><blockquote><p>如果没有启用HA，HDFS独立运行一个守护进程作为Secondary Namenode。定期checkpoint，合并镜像文件和edit日志。如果当主Namenode失败时，备份Namenode正在关机（停止 Standby），运维人员依然可以从头启动备份Namenode，这样比没有HA的时候更省事，算是一种改进，因为重启整个过程已经标准化到Hadoop内部，无需运维进行复杂的切换操作。<br>NameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。<br>每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败时触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful(优雅的) failover，非手动触发的failover称为ungraceful failover。<br>在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的editlog的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。</p></blockquote></li></ol><p>最后，HA方案中Namenode的切换对客户端来说是不可见的，前面已经介绍过，主要通过客户端库来完成。</p><h2 id="命令行接口"><a href="#命令行接口" class="headerlink" title="命令行接口"></a>命令行接口</h2><p>HDFS提供了各种交互方式，例如通过Java API、HTTP、shell命令行的。命令行的交互主要通过hadoop fs来操作。例如：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -copyFromLocal <span class="comment">// 从本地复制文件到HDFS</span></span><br><span class="line">hadoop fs <span class="keyword">mkdir</span> <span class="comment">// 创建目录</span></span><br><span class="line">hadoop fs -<span class="keyword">ls</span>  <span class="comment">// 列出文件列表</span></span><br></pre></td></tr></table></figure></p><h2 id="Hadoop文件系统"><a href="#Hadoop文件系统" class="headerlink" title="Hadoop文件系统"></a>Hadoop文件系统</h2><p>前面Hadoop的文件系统概念是抽象的，HDFS只是其中的一种实现。Hadoop提供的实现如下图：<br><img src="/2019/07/12/深入理解HDFS/xitongdexuanze.png" alt="Hadoop文件系统"><br>Local是对本地文件系统的抽象，hdfs就是我们最常见的，两种web形式（webhdfs，swebhdfs）的实现通过HTTP提供文件操作接口。har是Hadoop体系下的压缩文件，当文件很多的时候可以压缩成一个大文件，可以有效减少元数据的数量。viewfs就是我们前面介绍HDFS Federation张提到的，用来在客户端屏蔽多个Namenode的底层细节。ftp顾名思义，就是使用ftp协议来实现，对文件的操作转化为ftp协议。s3a是对Amazon云服务提供的存储系统的实现，azure则是微软的云服务平台实现。</p><p>前面我们提到了使用命令行跟HDFS交互，事实上还有很多方式来操作文件系统。例如Java应用程序可以使用org.apache.hadoop.fs.FileSystem来操作，其他形式的操作也都是基于FileSystem进行封装。我们这里主要介绍一下HTTP的交互方式。<br>WebHDFS和SWebHDFS协议将文件系统暴露HTTP操作，这种交互方式比原生的Java客户端慢，不适合操作大文件。通过HTTP，有2种访问方式，直接访问和通过代理访问<br><img src="http访问.png" alt="http访问"></p><p>Namenode和Datanode默认打开了嵌入式web server，即dfs.webhdfs.enabled默认为true。webhdfs通过这些服务器来交互。元数据的操作通过namenode完成，文件的读写首先发到namenode，然后重定向到datanode读取（写入）实际的数据流。</p><p>采用代理的示意图如下所示。 使用代理的好处是可以通过代理实现负载均衡或者对带宽进行限制，或者防火墙设置。代理通过HTTP或者HTTPS暴露为WebHDFS，对应为webhdfs和swebhdfs URL Schema。</p><p>代理作为独立的守护进程，独立于namenode和datanode，使用httpfs.sh脚本，默认运行在14000端口</p><p>除了FileSystem直接操作，命令行，HTTTP外，还有C语言API，NFS，FUSER等方式，这里不做过多介绍。<br><img src="/2019/07/12/深入理解HDFS/代理访问.png" alt="代理访问"></p><h2 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h2><p>实际的应用中，对HDFS的大多数操作还是通过FileSystem来操作，这部分重点介绍一下相关的接口，主要关注HDFS的实现类DistributedFileSystem及相关类。</p><ol><li>读操作</li></ol><p>可以使用URL来读取数据，或者直接使用FileSystem操作。</p><p>URL 获取流<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">in</span> = <span class="keyword">new</span> URL(<span class="string">"hdfs://master/user/hadoop"</span>).openStream();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"> IOUtils.closeStream(<span class="keyword">in</span>);</span><br></pre></td></tr></table></figure></p><p> FileSystem api获取流</p><p> · 首先获取FileSystem实例，一般使用静态get工厂方法<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">FileSystem</span> <span class="built_in">get</span>(Configuration conf) throws IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">FileSystem</span> <span class="built_in">get</span>(URI uri , Configuration conf) throws IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">FileSystem</span> <span class="built_in">get</span>(URI uri , Configuration conf，<span class="keyword">String</span> user) throws IOException</span><br></pre></td></tr></table></figure></p><p>· 如果是本地文件，通过getLocal获取本地文件系统对象：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LocalFileSystem getLocal(COnfiguration conf) thrown IOException</span><br></pre></td></tr></table></figure><p>· 调用FileSystem的open方法获取一个输入流:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FSDataInputStream <span class="built_in">open</span>(Path f) <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> abstarct FSDataInputStream <span class="built_in">open</span>(Path f , <span class="built_in">int</span> bufferSize) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></p><p>默认情况下，open使用4KB的Buffer，可以根据需要自行设置。</p><p>·使用FSDataInputStream进行数据操作<br>FSDataInputStream是java.io.DataInputStream的特殊实现，在其基础上增加了随机读取、部分读取的能力</p><p>·随机读取操作通过Seekable接口定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Seekable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">long</span> pos)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getPos</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>写数据</li></ol><p>在HDFS中，文件使用FileSystem类的create方法及其重载形式来创建，create方法返回一个输出流FSDataOutputStream，可以调用返回输出流的getPos方法查看当前文件的位移，但是不能进行seek操作，HDFS仅支持追加操作。</p><p>创建时，可以传递一个回调接口Peofressable，获取进度信息</p><p>append(Path f)方法用于追加内容到已有文件，但是并不是所有的实现都提供该方法，例如Amazon的文件实现就没有提供追加功能。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> localSrc =  args[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">String</span> dst = args[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">InputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="type">BufferedInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(localSrc));</span><br><span class="line"> </span><br><span class="line">Configuration conf = <span class="keyword">new</span> <span class="type">Configuration</span>();</span><br><span class="line">FileSystem fs = FileSystem.<span class="keyword">get</span>(URI.create(dst),conf);</span><br><span class="line"> </span><br><span class="line">OutputStream out = fs.create(<span class="keyword">new</span> <span class="type">Path</span>(dst), <span class="keyword">new</span> <span class="type">Progressable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> vid progress()&#123;</span><br><span class="line">        System.out.print(.);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">IOUtils.copyBytes(<span class="keyword">in</span> , out, <span class="number">4096</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>目录操作</li></ol><p>使用mkdirs（）方法,会自动创建没有的上级目录</p><p>HDFS中元数据封装在FileStatus类中，包括长度、block size，replicaions，修改时间、所有者、权限等信息。使用FileSystem提供的getFileStatus方法获取FileStatus。exists()方法判断文件或者目录是否存在；</p><p>列出文件（list），则使用listStatus方法，可以查看文件或者目录的信息</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> FileStatus[] listStatus(Path f) <span class="keyword">throws</span> FileNotFoundException,IOException;</span><br></pre></td></tr></table></figure><p>PathFilter用于自定义文件名过滤，不能根据文件属性进行过滤，类似于java.io.FileFilter。例如下面这个例子排除到给定正则表达式的文件：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> interfacePathFilter&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(Path path)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>删除数据</li></ol><p>使用FileSystem的delete()方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Path f , <span class="keyword">boolean</span> recursive)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>recursive参数在f是个文件的时候被忽略。如果f是文件并且recursice为true，则删除整个目录，否则抛出异常.</p><h2 id="数据流-读写流程）"><a href="#数据流-读写流程）" class="headerlink" title="数据流(读写流程）"></a>数据流(读写流程）</h2><p>接下来详细介绍HDFS读写数据的流程，以及一致性模型相关的一些概念。</p><ol><li>读文件</li></ol><p>大致读文件的流程如下：</p><p><img src="/2019/07/12/深入理解HDFS/读文件.png" alt="读文件"></p><p>1）客户端传递一个文件Path给FileSystem的open方法</p><p>2）DFS采用RPC远程获取文件最开始的几个block的datanode地址。Namenode会根据网络拓扑结构决定返回哪些节点（前提是节点有block副本），如果客户端本身是Datanode并且节点上刚好有block副本，直接从本地读取。</p><p>3）客户端使用open方法返回的FSDataInputStream对象读取数据（调用read方法）</p><p>4）DFSInputStream（FSDataInputStream实现了改类）连接持有第一个block的、最近的节点，反复调用read方法读取数据</p><p>5）第一个block读取完毕之后，寻找下一个block的最佳datanode，读取数据。如果有必要，DFSInputStream会联系Namenode获取下一批Block 的节点信息(存放于内存，不持久化），这些寻址过程对客户端都是不可见的。</p><p>6）数据读取完毕，客户端调用close方法关闭流对象</p><p>在读数据过程中，如果与Datanode的通信发生错误，DFSInputStream对象会尝试从下一个最佳节点读取数据，并且记住该失败节点， 后续Block的读取不会再连接该节点<br>读取一个Block之后，DFSInputStram会进行检验和验证，如果Block损坏，尝试从其他节点读取数据，并且将损坏的block汇报给Namenode。<br>客户端连接哪个datanode获取数据，是由namenode来指导的，这样可以支持大量并发的客户端请求，namenode尽可能将流量均匀分布到整个集群。<br>Block的位置信息是存储在namenode的内存中，因此相应位置请求非常高效，不会成为瓶颈。</p><ol start="2"><li>写文件</li></ol><p><img src="/2019/07/12/深入理解HDFS/写文件.png" alt="写文件"></p><p>步骤分解<br>1）客户端调用DistributedFileSystem的create方法</p><p>2）DistributedFileSystem远程RPC调用Namenode在文件系统的命名空间中创建一个新文件，此时该文件没有关联到任何block。 这个过程中，Namenode会做很多校验工作，例如是否已经存在同名文件，是否有权限，如果验证通过，返回一个FSDataOutputStream对象。 如果验证不通过，抛出异常到客户端。</p><p>3）客户端写入数据的时候，DFSOutputStream分解为packets（数据包），并写入到一个数据队列中，该队列由DataStreamer消费。</p><p>4）DateStreamer负责请求Namenode分配新的block存放的数据节点。这些节点存放同一个Block的副本，构成一个管道。 DataStreamer将packet写入到管道的第一个节点，第一个节点存放好packet之后，转发给下一个节点，下一个节点存放 之后继续往下传递。</p><p>5）DFSOutputStream同时维护一个ack queue队列，等待来自datanode确认消息。当管道上的所有datanode都确认之后，packet从ack队列中移除。</p><p>6）数据写入完毕，客户端close输出流。将所有的packet刷新到管道中，然后安心等待来自datanode的确认消息。全部得到确认之后告知Namenode文件是完整的。 Namenode此时已经知道文件的所有Block信息（因为DataStreamer是请求Namenode分配block的），只需等待达到最小副本数要求，然后返回成功信息给客户端。</p><p>Namenode如何决定副本存在哪个Datanode？</p><p>HDFS的副本的存放策略是可靠性、写带宽、读带宽之间的权衡。默认策略如下：</p><p>第一个副本放在客户端相同的机器上，如果机器在集群之外，随机选择一个（但是会尽可能选择容量不是太慢或者当前操作太繁忙的）<br>第二个副本随机放在不同于第一个副本的机架上。<br>第三个副本放在跟第二个副本同一机架上，但是不同的节点上，满足条件的节点中随机选择。<br>更多的副本在整个集群上随机选择，虽然会尽量避免太多副本在同一机架上。<br>副本的位置确定之后，在建立写入管道的时候，会考虑网络拓扑结构。<br>下面是可能的一个存放策略:</p><p><img src="/2019/07/12/深入理解HDFS/副本存放.png" alt="副本存放.png"></p><p>这样选择很好滴平衡了可靠性、读写性能</p><p>可靠性：Block分布在两个机架上<br>写带宽：写入管道的过程只需要跨越一个交换机<br>读带宽：可以从两个机架中任选一个读取</p><ol start="3"><li>一致性模型</li></ol><p>一致性模型描述文件系统中读写操纵的可见性。HDFS中，文件一旦创建之后，在文件系统的命名空间中可见：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path p = <span class="keyword">new</span> Path(<span class="string">"p"</span>);</span><br><span class="line">fs.create(p);</span><br><span class="line">assertTaht(fs.exists(p),<span class="keyword">is</span>(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure><p>但是任何被写入到文件的内容不保证可见，即使对象流已经被刷新。 </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path p = new Path(“p”); </span><br><span class="line">OutputStream <span class="keyword">out</span> = fs.create(p); </span><br><span class="line"><span class="keyword">out</span>.<span class="built_in">write</span>(“content”.getBytes(“UTF-<span class="number">8</span>”)); </span><br><span class="line"><span class="keyword">out</span>.<span class="keyword">flush</span>(); </span><br><span class="line">assertTaht(fs.getFileStatus(p).getLen,L); // 为<span class="number">0</span>，即使调用了<span class="keyword">flush</span></span><br></pre></td></tr></table></figure><p>关闭对象流时，内部会调用hflush方法,但是hflush不保证datanode数据已经写入到磁盘，只是保证写入到datanode的内存， 因此在机器断电的时候可能导致数据丢失，如果要保证写入磁盘，使用hsync方法，hsync类型与fsync（）的系统调用，fsync提交某个文件句柄的缓冲数据。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStreamout = <span class="keyword">new</span> FileOutPutStream(localFile);</span><br><span class="line"><span class="keyword">out</span>.write(<span class="string">"content"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="keyword">out</span>.flush();</span><br><span class="line"><span class="keyword">out</span>.getFD().sync();</span><br><span class="line">assertTaht(localFile.getLen,<span class="keyword">is</span>(((<span class="keyword">long</span>,<span class="string">"content"</span>.length())));</span><br></pre></td></tr></table></figure><p>使用hflush或hsync会导致吞吐量下降，因此设计应用时，需要在吞吐量以及数据的健壮性之间做权衡。</p><p>另外，文件写入过程中，当前正在写入的Block对其他Reader不可见。</p><ol start="4"><li>Hadoop节点距离</li></ol><p>在读取和写入的过程中，namenode在分配Datanode的时候，会考虑节点之间的距离。HDFS中，距离没有<br>采用带宽来衡量，因为实际中很难准确度量两台机器之间的带宽。<br>Hadoop把机器之间的拓扑结构组织成树结构，并且用到达公共父节点所需跳转数之和作为距离。事实上这是一个距离矩阵的例子。下面的例子简明地说明了距离的计算：</p><p><img src="/2019/07/12/深入理解HDFS/Hadoop节点距离.png" alt="Hadoop节点距离.png"></p><p>同一数据中心，同一机架，同一节点距离为0</p><p>同一数据中心，同一机架，不同节点距离为2</p><p>同一数据中心，不同机架，不同节点距离为4</p><p>不同数据中心，不同机架，不同节点距离为6</p><p>Hadoop集群的拓扑结构需要手动配置，如果没配置，Hadoop默认所有节点位于同一个数据中心的同一机架上。</p><h2 id="一次sqoop的离线"><a href="#一次sqoop的离线" class="headerlink" title="一次sqoop的离线"></a>一次sqoop的离线</h2><p>从mysql—&gt;hdfs</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;胡思乱想&quot;&gt;&lt;a href=&quot;#胡思乱想&quot; class=&quot;headerlink&quot; title=&quot;胡思乱想&quot;&gt;&lt;/a&gt;胡思乱想&lt;/h2&gt;&lt;p&gt;HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Had
      
    
    </summary>
    
      <category term="大数据" scheme="https://www.nouyc.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="HDFS" scheme="https://www.nouyc.com/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>普罗米修斯监控</title>
    <link href="https://www.nouyc.com/2019/07/11/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9B%91%E6%8E%A7/"/>
    <id>https://www.nouyc.com/2019/07/11/普罗米修斯监控/</id>
    <published>2019-07-11T09:47:12.000Z</published>
    <updated>2019-07-11T09:56:34.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>作为新一代的监控框架，Prometheus 具有以下特点：</p><p> · 强大的多维度数据模型：<br>   时间序列数据通过 metric 名和键值对来区分。<br>   所有的 metrics 都可以设置任意的多维标签。<br>   数据模型更随意，不需要刻意设置为以点分隔的字符串。<br>   可以对数据模型进行聚合，切割和切片操作。<br>   支持双精度浮点类型，标签可以设为全 unicode。<br> · 灵活而强大的查询语句（PromQL）：<br> · 易于管理： Prometheus server 是一个单独的二进制文件，可直接在本地工作，不依赖于分布式存储。<br>·高效：平均每个采样点仅占 3.5 bytes，且一个 Prometheus server ·可以处理数百万的 metrics。<br>·使用 pull 模式采集时间序列数据，这样不仅有利于本机测试而且可以避免有问题的服务器推送坏的 metrics。<br>·可以采用 push gateway 的方式把时间序列数据推送至 Prometheus server 端。<br>·可以通过服务发现或者静态配置去获取监控的 targets。<br>·有多种可视化图形界面。<br>·易于伸缩。<br>·需要指出的是，由于数据采集可能会有丢失，所以Prometheus不适用对采集数据要 100%准确的情形。但如果用于记录时间序列数据，Prometheus具有很大的查询优势，此外，Prometheus 适用于微服务的体系架构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;作为新一代的监控框架，Prometheus 具有以下特点：&lt;/p&gt;
&lt;p&gt; · 强大的多维度数据模型：&lt;br&gt;   时间序列数据通过 met
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dubbo项目结构搞一搞</title>
    <link href="https://www.nouyc.com/2019/07/01/dubbo%E6%B7%B1%E5%BA%A6%E6%90%9E%E4%B8%80%E6%90%9E/"/>
    <id>https://www.nouyc.com/2019/07/01/dubbo深度搞一搞/</id>
    <published>2019-07-01T09:41:19.000Z</published>
    <updated>2020-03-17T06:46:53.082Z</updated>
    
    <content type="html"><![CDATA[<p>各层说明总结（参考dubbo源码）</p><p>==================== Business ====================<br>Service 业务层：业务代码的接口与实现。我们实际使用 Dubbo<br>==================== RPC ====================<br>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 Spring 解析配置生成配置类。</p><p>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory 。</p><p>dubbo-rpc-rpc 模块实现。<br>com.alibaba.dubbo.rpc.proxy包 + com.alibaba.dubbo.rpc.ProxyFactory接口 。</p><p>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService 。<br>dubbo-registry 模块实现。<br>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance 。</p><p>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService 。<br>dubbo-monitor 模块实现。<br>==================== Remoting ====================<br>protocol 远程调用层：封将 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter 。<br>dubbo-rpc-rpc 模块实现。<br>com.alibaba.dubbo.rpc.protocol包 + com.alibaba.dubbo.rpc.Protocol接口 。</p><p>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer 。<br>dubbo-remoting-api 模块定义接口。<br>com.alibaba.dubbo.remoting.exchange包。<br>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec 。<br>dubbo-remoting-api 模块定义接口。<br>com.alibaba.dubbo.remoting.transport包。<br>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool 。<br>dubbo-common 模块实现。<br>com.alibaba.dubbo.common.serialize包。</p><h2 id="分享-Dubbo-的项目结构。"><a href="#分享-Dubbo-的项目结构。" class="headerlink" title="分享 Dubbo 的项目结构。"></a>分享 Dubbo 的项目结构。</h2><ol><li>万事第一步拉取dubbo源码</li></ol><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo项目预览.png" alt></p><ol start="2"><li>代码统计</li></ol><p>这里先分享一个小技巧。笔者在开始源码学习时，会首先了解项目的代码量。</p><p>第一种方式，使用 IDEA Statistic 插件，统计整体代码量。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo源码行数.png" alt></p><p>还有一种方式，使用 Shell 脚本命令逐个 Maven 模块统计 。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：find . -name <span class="string">"*.java"</span>|<span class="type">xargs</span> cat|<span class="type">grep</span> -v -e ^$ -e ^\s*\/\/.*$|<span class="type">wc</span> -l</span><br></pre></td></tr></table></figure><p>这个命令只过滤了部分注释，所以相比 IDEA Statistic 会偏多。</p><p>当然，考虑到准确性，胖友需要手动 cd 到每个 Maven 项目的 src/main/java 目录下，以达到排除单元测试的代码量。</p><ol start="3"><li>项目一览</li></ol><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo项目一览.png" alt></p><h2 id="逐个分析每一个工程"><a href="#逐个分析每一个工程" class="headerlink" title="逐个分析每一个工程"></a>逐个分析每一个工程</h2><p>3.1 dubbo-common</p><p>dubbo-common 公共逻辑模块：提供工具类和通用模型。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo-common.jpg" alt></p><p>工具类比较好理解，通用模型是什么？举个例子，com.alibaba.dubbo.common.URL ：</p><blockquote><p>所有扩展点参数都包含 URL 参数，URL 作为上下文信息贯穿整个扩展点设计体系。<br>URL 采用标准格式：protocol://username:password@host:port/path?key=value&amp;<br>key=value 。</p></blockquote><p>3.2 dubbo-remoting</p><p>dubbo-remoting 远程通信模块：提供通用的客户端和服务端的通讯功能。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo-remoting.png" alt></p><ul><li>dubbo-remoting-zookeeper ，相当于 Zookeeper Client ，和 Zookeeper Server 通信。</li><li>dubbo-remoting-api ， 定义了 Dubbo Client 和 Dubbo Server 的接口。</li><li>实现 dubbo-remoting-api</li><li>dubbo-remoting-grizzly ，基于 Grizzly 实现。</li><li>dubbo-remoting-http ，基于 Jetty 或 Tomcat 实现。</li><li>dubbo-remoting-mina ，基于 Mina 实现。</li><li>dubbo-remoting-netty ，基于 Netty 3 实现。</li><li>dubbo-remoting-netty4 ，基于 Netty 4 实现。</li><li><p>dubbo-remoting-p2p ，P2P 服务器。注册中心 dubbo-registry-multicast 项目的使用该项目。<br>从最小化的角度来看，我们只需要看：</p></li><li><p>dubbo-remoting-api + dubbo-remoting-netty4</p></li><li>dubbo-remoting-zookeeper</li></ul><p>3.3 dubbo-rpc<br>dubbo-rpc 远程调用模块：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo-rpc.png" alt></p><ul><li>dubbo-rpc-api ，抽象各种协议以及动态代理，实现了一对一的调用。</li><li>其他模块，实现 dubbo-rpc-api ，提供对应的协议实现。在 《用户指南 —— 协议参考手册》 中，可以看到每种协议的介绍。</li><li>另外，dubbo-rpc-default 对应 dubbo:// 协议。</li></ul><p>3.4 dubbo-cluster<br>dubbo-cluster 集群模块：将多个服务提供方伪装为一个提供方，包括：负载均衡, 集群容错，路由，分组聚合等。集群的地址列表可以是静态配置的，也可以是由注册中心下发。</p><p>注册中心下发，由 dubbo-registry 提供特性。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo-cluster.png" alt></p><p>-容错</p><ul><li>com.alibaba.dubbo.rpc.cluster.Cluster 接口 + com.alibaba.dubbo.rpc.cluster.support 包。</li><li>Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。</li><li>拓展参见 《Dubbo 用户指南 —— 集群容错》 和 《Dubbo 开发指南 —— 集群扩展》 文档。</li><li>目录</li><li>com.alibaba.dubbo.rpc.cluster.Directory 接口 + com.alibaba.dubbo.rpc.cluster.directory 包。</li><li>Directory 代表了多个 Invoker ，可以把它看成 List ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更。</li><li>路由</li><li>com.alibaba.dubbo.rpc.cluster.Router 接口 + com.alibaba.dubbo.rpc.cluster.router 包。</li><li>负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等。</li><li>拓展参见 《Dubbo 用户指南 —— 路由规则》 和 《Dubbo 开发指南 —— 路由拓展》 文档。</li><li>配置</li><li>com.alibaba.dubbo.rpc.cluster.Configurator 接口 + com.alibaba.dubbo.rpc.cluster.configurator 包。</li><li>拓展参见 《Dubbo 用户指南 —— 配置规则》 文档。</li><li>负载均衡</li><li>com.alibaba.dubbo.rpc.cluster.LoadBalance 接口 + com.alibaba.dubbo.rpc.cluster.loadbalance 包。</li><li>LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。</li><li>拓展参见 《Dubbo 用户指南 —— 负载均衡》 和 《Dubbo 开发指南 —— 负载均衡拓展》 文档。</li><li>合并结果</li><li>com.alibaba.dubbo.rpc.cluster.Merger 接口 + com.alibaba.dubbo.rpc.cluster.merger 包。</li><li>合并返回结果，用于分组聚合。</li><li>拓展参见 《Dubbo 用户指南 —— 分组聚合》 和 《Dubbo 开发指南 —— 合并结果扩展》 文档。</li></ul><p>整体流程如下：</p><p><img src="/2019/07/01/dubbo深度搞一搞/cluster-整体.png" alt></p><p>3.5 dubbo-registry</p><p>dubbo-registry 注册中心模块：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</p><ul><li>dubbo-registry-api ，抽象注册中心的注册与发现接口。</li><li>其他模块，实现 dubbo-registry-api ，提供对应的注册中心实现。在 《用户指南 —— 注册中心参考手册》 中，可以看到每种注册中心的介绍。</li><li>另外，dubbo-registry-default 对应 Simple 注册中心。</li><li>拓展参见 《Dubbo 开发指南 —— 注册中心扩展》 文档。</li></ul><p>3.6 dubbo-monitor<br>dubbo-monitor 监控模块：统计服务调用次数，调用时间的，调用链跟踪的服务。<br><img src="/2019/07/01/dubbo深度搞一搞/dubbo-monitor.png" alt></p><ul><li>拓展参见 《Dubbo 开发指南 —— 监控中心扩展》 。</li><li>目前社区里，有对 Dubbo 监控中心进行重构的项目，例如 ：</li><li><a href="https://github.com/handuyishe/dubbo-monitor" target="_blank" rel="noopener">https://github.com/handuyishe/dubbo-monitor</a></li><li><a href="https://github.com/zhongxig/dubbo-d-monitor" target="_blank" rel="noopener">https://github.com/zhongxig/dubbo-d-monitor</a></li></ul><p>3.7 dubbo-config</p><p>dubbo-config 配置模块：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo-config.png" alt></p><ul><li>dubbo-config-api ，实现了 API 配置 和 属性配置 功能。</li><li>dubbo-config-spring ，实现了 XML 配置 和 注解配置 功能。</li><li>推荐阅读 《Dubbo 开发指南 —— 配置设计》。</li></ul><p>3.8 dubbo-container<br>dubbo-container 容器模块：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo-container.png" alt></p><ul><li>dubbo-container-api ：定义了 com.alibaba.dubbo.container.Container 接口，并提供 加载所有容器启动的 Main 类。</li><li>实现 dubbo-container-api</li><li>dubbo-container-spring ，提供了 com.alibaba.dubbo.container.spring.SpringContainer 。</li><li>dubbo-container-log4j ，提供了 com.alibaba.dubbo.container.log4j.Log4jContainer 。</li><li>dubbo-container-logback ，提供了 com.alibaba.dubbo.container.logback.LogbackContainer 。</li><li>拓展参考 《Dubbo 用户指南 —— 服务容器》 和 《Dubbo 开发指南 —— 容器扩展》 文档。</li></ul><p>3.9 dubbo-filter</p><p>dubbo-filter 过滤器模块：提供了内置的过滤器。</p><p><img src="/2019/07/01/dubbo深度搞一搞/dubbo-filter.png" alt></p><ul><li>dubbo-filter-cache ，缓存过滤器。</li><li>拓展参考 《Dubbo 用户指南 —— 结果缓存》 和 《Dubbo 开发指南 —— 缓存拓展》 文档。</li><li>dubbo-filter-validation ，参数验证过滤器。</li><li>拓展参考 《Dubbo 用户指南 —— 参数验证》 和 《Dubbo 开发指南 —— 验证扩展》 文档。</li></ul><p>3.10 dubbo-plugin</p><ul><li>dubbo-plugin 插件模块：提供了内置的插件。</li><li>dubbo-qos ，提供在线运维命令。</li><li>拓展参考 《Dubbo 用户指南 —— 新版本 telnet 命令使用说明》 和 《Dubbo 开发指南 —— Telnet 命令扩展》 文档。</li></ul><p>3.11 hessian-lite<br>hessian-lite ：Dubbo 对 Hessian 2 的 序列化 部分的精简、改进、BugFix 。</p><p>3.14 Maven POM</p><p><img src="/2019/07/01/dubbo深度搞一搞/MavenPOM.png" alt></p><p>3.14.1 dubbo-all</p><p>dubbo/all/pom.xml ，Dubbo All Pom ，定义了 Dubbo 的打包脚本。</p><p>我们在使用 Dubbo 库时，引入该 pom 文件。</p><p>==================== 手撸一套模拟dubbo ====================<br>敬请关注</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;各层说明总结（参考dubbo源码）&lt;/p&gt;
&lt;p&gt;==================== Business ====================&lt;br&gt;Service 业务层：业务代码的接口与实现。我们实际使用 Dubbo&lt;br&gt;===================
      
    
    </summary>
    
    
      <category term="dubbo" scheme="https://www.nouyc.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>一套客服系统的服务端</title>
    <link href="https://www.nouyc.com/2019/05/30/%E4%B8%80%E5%A5%97%E5%AE%A2%E6%9C%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://www.nouyc.com/2019/05/30/一套客服系统的服务端/</id>
    <published>2019-05-30T03:05:10.000Z</published>
    <updated>2019-06-24T07:18:10.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的客服IM"><a href="#我的客服IM" class="headerlink" title="我的客服IM"></a>我的客服IM</h2><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>gate</p><p>###创建场景、登陆jwt校验、获取会话列表和会话页、种类消息、消息推送、结束评价</p><p>###</p><h2 id="网络编程思想"><a href="#网络编程思想" class="headerlink" title="网络编程思想"></a>网络编程思想</h2><p>通信协议、通信接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我的客服IM&quot;&gt;&lt;a href=&quot;#我的客服IM&quot; class=&quot;headerlink&quot; title=&quot;我的客服IM&quot;&gt;&lt;/a&gt;我的客服IM&lt;/h2&gt;&lt;h2 id=&quot;模块划分&quot;&gt;&lt;a href=&quot;#模块划分&quot; class=&quot;headerlink&quot; title=&quot;模
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阿里dubbo---北京MeetUp会议记录2019.5.26</title>
    <link href="https://www.nouyc.com/2019/05/26/%E5%9C%A8%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://www.nouyc.com/2019/05/26/在应用如何做好分布式事务/</id>
    <published>2019-05-26T02:45:53.000Z</published>
    <updated>2019-05-26T08:41:33.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XA模式-主讲（申海强）"><a href="#XA模式-主讲（申海强）" class="headerlink" title="XA模式  主讲（申海强）"></a>XA模式  主讲（申海强）</h2><p>锁–我们在传统的系统进行请求访问的时候，一次请求都要经过XA，start-end，涉及了很多分布式事务的锁。</p><p>连接–如果说链路太长，那么这个连接不能释放。</p><p>TM begin-  TC 事务id -  RM 注册TC 统一用TC回溯（回追一些事务）— TM end</p><p>###本地模式必须遵守ACID</p><p>牛逼的点：undoLog TC - Rm</p><p>来嵌套下，saga tcc 模式</p><p>###提问环节</p><ol><li>对于olap也没有很好的办法，本架构也主要在oltp进行开展。</li><li>TC高可用是否可以得到保障，一个新技术引入架构的话，是一个单点隐患，复杂的问题聚焦到一个点。</li><li>undoLog确定是存在数据库中，这就解释了本地模式为什么是acid。</li><li>TC对链路的控制，优先选择第一条链路。</li><li>其他外国大厂并没有对微服务层次上对事务有把控、只是在数据库上做了。</li></ol><h2 id="apache-dubbo的设想-主讲（秦金卫）"><a href="#apache-dubbo的设想-主讲（秦金卫）" class="headerlink" title="apache dubbo的设想 主讲（秦金卫）"></a>apache dubbo的设想 主讲（秦金卫）</h2><p>dubbo的想法</p><p>abc基础能力</p><p>云一体化、人工智能、大数据。悄悄告诉大家，如果创业，这三方面一定占据几个</p><p>###生态</p><ol><li><p>商场模式，all in one.所有东西都放在一个商场中，什么都有，吸引所有人进来。一旦全部链路打通后，就成了大家习惯的一种姿态。</p></li><li><p>容器模式 单独部署、单独建立</p></li></ol><p>###如何发展</p><ol><li>聚焦于行业领域</li><li>定制化</li><li>社区完善</li></ol><p>###dubbo 一个发展很牛逼的东西，可以看成是eip、不用修改一行代码， 直接暴露出所有东西。</p><p>###欢迎参与阿里开源</p><p>###提问环节</p><ol><li>用新技术搭新工程其实是技术选型问题。</li><li>如果是面对老系统，其实就是和旧世界作斗争，选择办法打通一条通往新世界的大门，开一个口子接入新系统</li><li>eip目前还在处于构造中。</li></ol><h2 id="sentinel-网关限流-赵亦豪（宿何）"><a href="#sentinel-网关限流-赵亦豪（宿何）" class="headerlink" title="sentinel 网关限流 赵亦豪（宿何）"></a>sentinel 网关限流 赵亦豪（宿何）</h2><p>sentinel<br>微服务稳定性的场景</p><p>场景：</p><ol><li>激增流量</li><li>下游服务的不稳定性<br>可行性：</li><li>流量控制</li><li>流量整型</li><li>熔断降级</li><li>系统自适应保护</li></ol><p>要在系统出现堕机前进行，进行保护</p><p>###1.6.0新特性</p><ol><li><p>注解的支持改进</p></li><li><p>异常类型限定</p></li><li><p>网关流量控制</p></li><li><p>更好的errorCallBack的返回</p></li><li><p>开源万岁</p></li></ol><p>###提问环节</p><ol><li>一旦集成后，动态server的管理：可以搞成一种独立模式的一种agent。</li><li>sentinel熔断没有一个半打开的功能。豪猪有</li></ol><h2 id="dubbo服务自省设计与实现-主讲（今天最牛逼的小马哥）"><a href="#dubbo服务自省设计与实现-主讲（今天最牛逼的小马哥）" class="headerlink" title="dubbo服务自省设计与实现 主讲（今天最牛逼的小马哥）"></a>dubbo服务自省设计与实现 主讲（今天最牛逼的小马哥）</h2><p>什么是服务自省</p><p>dubbo可以暴露很多协议，dubbo应用在运行时处理和分析dubbo的服务元信息</p><p>dubbo对外提供的是服务，cloud是接口。微服务还有些地方不是特别成熟，本次升级dubbo自省模式，加入了metaData原数据。</p><h2 id="zk向nacos的迁移"><a href="#zk向nacos的迁移" class="headerlink" title="zk向nacos的迁移"></a>zk向nacos的迁移</h2><p>一句话，早晚的事，zk其实挺被诟病的，只是因为没有更好的一个选择，注册中心这个概念，正是因为确定保证它的稳定性，所以要开发出的一个良好的模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XA模式-主讲（申海强）&quot;&gt;&lt;a href=&quot;#XA模式-主讲（申海强）&quot; class=&quot;headerlink&quot; title=&quot;XA模式  主讲（申海强）&quot;&gt;&lt;/a&gt;XA模式  主讲（申海强）&lt;/h2&gt;&lt;p&gt;锁–我们在传统的系统进行请求访问的时候，一次请求都要经过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我是菜鸟---java基础通用复习篇</title>
    <link href="https://www.nouyc.com/2019/05/15/%E6%88%91%E6%98%AF%E8%8F%9C%E9%B8%9F-java%E5%9F%BA%E7%A1%80%E9%80%9A%E7%94%A8%E5%A4%8D%E4%B9%A0%E7%AF%87/"/>
    <id>https://www.nouyc.com/2019/05/15/我是菜鸟-java基础通用复习篇/</id>
    <published>2019-05-15T07:39:55.000Z</published>
    <updated>2019-06-06T08:56:31.257Z</updated>
    
    <content type="html"><![CDATA[<p>java集合、java并发、java网络、java虚拟机</p><p>面向对象是java的一句代表</p><p>面向对象的特征？四点记住！封装、继承、多态、抽象。</p><h2 id="面向对象—封装"><a href="#面向对象—封装" class="headerlink" title="面向对象—封装"></a>面向对象—封装</h2><p>封装给对象提供了隐藏内部特性和行为的能力，对象提供一些给其他对象改变自己内部参数的方法。这么一说比较绕，简单来讲就是我们常见的四种类修饰符：<br>private、friendly、projected、public。这些修饰符给对象赋予了不同的访问权限。</p><p>封装的好处：通过隐藏对象的属性来保护对象内部的状态，提高了代码可读性、维护性。模块化。</p><h2 id="面向对象—继承"><a href="#面向对象—继承" class="headerlink" title="面向对象—继承"></a>面向对象—继承</h2><p>继承，给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p><h2 id="面向对象—多态"><a href="#面向对象—多态" class="headerlink" title="面向对象—多态"></a>面向对象—多态</h2><p>多态，是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作，可以应用到其他类型的值上面。</p><h2 id="面向对象—抽象"><a href="#面向对象—抽象" class="headerlink" title="面向对象—抽象"></a>面向对象—抽象</h2><p>抽象，是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。<br>Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p><h2 id="面向过程与面向对象的区别"><a href="#面向过程与面向对象的区别" class="headerlink" title="面向过程与面向对象的区别"></a>面向过程与面向对象的区别</h2><p>性能高低不同，自己想想哪个高低？</p><h2 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h2><p>1）重写 override</p><p>方法名、参数、返回值相同。<br>子类方法不能缩小父类方法的访问权限。<br>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。<br>存在于父类和子类之间。<br>方法被定义为 final 不能被重写。</p><p>2）重载 overload</p><p>参数类型、个数、顺序至少有一个不相同。<br>不能重载只有返回值不同的方法名。<br>存在于父类和子类、同类中。</p><h2 id="Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"><a href="#Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？" class="headerlink" title="Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"></a>Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？</h2><p>1）构造方法</p><p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。</p><p>2）构造方法重载</p><p>Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p><p>3）拷贝构造方法</p><p>Java 不支持像 C++ 中那样的拷贝构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。</p><h2 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h2><p>🐷JDK<br>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：</p><p>用于编译 Java 程序的 javac 命令。<br>用于启动 JVM 运行 Java 程序的 Java 命令。<br>用于生成文档的 Javadoc 命令。<br>用于打包的 jar 命令等等。</p><p>简单说，就是 JDK 包含 JRE 包含 JVM。</p><p>🐷JRE</p><p>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p><p>简单说，就是 JRE 包含 JVM。</p><p>🐷JVM</p><h2 id="为什么-Java-被称作是“平台无关的编程语言”？"><a href="#为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="为什么 Java 被称作是“平台无关的编程语言”？"></a>为什么 Java 被称作是“平台无关的编程语言”？</h2><p>Java 源文件( .java )被编译成能被 Java 虚拟机执行的字节码文件( .class )。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p><h2 id="JDK-各版本的新特性？"><a href="#JDK-各版本的新特性？" class="headerlink" title="JDK 各版本的新特性？"></a>JDK 各版本的新特性？</h2><p>JDK5 ~ JDK10 ，看 <a href="https://www.jianshu.com/p/37b52f1ebd4a" target="_blank" rel="noopener">https://www.jianshu.com/p/37b52f1ebd4a</a> 。<br>JDK11 ，看 <a href="https://www.jianshu.com/p/81b65eded96c" target="_blank" rel="noopener">https://www.jianshu.com/p/81b65eded96c</a> 。<br>对于大多数面试官，肯定不会问你 JDK 各版本的新特性，更多的会问 JDK8 引入了什么重要的特性？一般上，关键的回答是Lambda 表达式和集合之流式操作，然后说说你在项目中怎么使用的。</p><p>JVM 即为 Java 虚拟机，提供了字节码文件(.class)的运行环境支持。</p><h2 id="Java-和-C-的区别？"><a href="#Java-和-C-的区别？" class="headerlink" title="Java 和 C++ 的区别？"></a>Java 和 C++ 的区别？</h2><p>都是面向对象的语言，都支持封装、继承和多态。<br>Java 不提供指针来直接访问内存，程序内存更加安全。<br>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。<br>【重要】Java 有自动内存管理机制，不需要程序员手动释放无用内存。</p><h2 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h2><p>这个问题，面试官可以衍生提问，Java 是编译执行的语言，还是解释执行的语言。</p><p>Java 源代码<br>=&gt; 编译器 =&gt; JVM 可执行的 Java 字节码(即虚拟指令)<br>=&gt; JVM =&gt; JVM 中解释器 =&gt; 机器可执行的二进制机器码 =&gt; 程序运行</p><p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。</p><h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><p>集合框架我觉得不管是学习知识还死活开发实战都是必要的，不可苟且。</p><p>一个工具类中的集合可以提高很多的性能。</p><p>map collection</p><p>map set list。</p><h2 id="递归的使用"><a href="#递归的使用" class="headerlink" title="递归的使用"></a>递归的使用</h2><p>递归的使用要定义递归头和递归体。<br>递归头定义出什么时候不调用自己，否则会出现死循环。<br>递归体定义什么什么时候调用自己。<br>但递归太耗费性能了，考虑的话完全可以用循环来替代。</p><h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><p>c语言面向过程。java面向过程。<br>都是设计软件的基本思想，相辅相成，不是对立的。<br>面向过程，遇到事了，专注于怎么做，比如说第一步怎么做、第二步怎么做，就是面向过程。面向过程适合简单任务，简单任务是指不需要协作的事务。<br>面向对象，解决复杂问题，宏观上使用面向对象把握，但是微观处理仍然是面向过程。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>可以看为数据管理的方式，也可以看为内存中的一个内存块，包含了很多数据。<br>程序发展之初是不需要对象的，只需要基本数据类型就可以了。但是事物的发展总是量变引起质变。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>对象的概念由小作坊到大楼、到公司、到大楼。</p><p>对象和类的概念，类可以看作对象的模版。类中包含了成员变量和方法。</p><p>见到new就是调用一个类的构造方法，new出来了一个实例，这个无参构造方法默认是系统自动创建的。</p><h2 id="java虚拟机-jvm"><a href="#java虚拟机-jvm" class="headerlink" title="java虚拟机 jvm"></a>java虚拟机 jvm</h2><p>说下几个jvm中的概念吧：栈、堆、方法区。</p><p>######栈</p><ol><li>栈描述的就是方法执行的模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）。</li><li>java为每个线程提供一个栈，用于存放该线程执行的方法信息</li><li>栈属于线程私有，不能实现共享。</li><li>栈的特性，结合方法的使用来思考。</li><li>栈是由系统自动分配，速度快，栈是一个连续的内存空间。</li></ol><p>######堆</p><ol><li>堆用于存储对象创建好的对象和数组，数组也是对象。</li><li>jvm只有一个堆，线程共享。</li><li>堆的内存不连续。</li></ol><p>######方法区</p><ol><li>方法区其实也是堆。</li><li>用于存储类相关的信息。</li><li>用于存储程序中永远不变或者唯一的内容：class信息、静态变量、字符串常量、class对象。</li></ol><p>一次简单的函数调用，需要去画一次内存分配和执行流程<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class execise &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    void study()&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习中，学习人："</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    void age()&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习的年龄"</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> User </span>user;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        execise execise = new execise();</span><br><span class="line"></span><br><span class="line">        execise.age = 30;</span><br><span class="line">        execise.name = <span class="string">"nounounou"</span>;</span><br><span class="line"></span><br><span class="line">        execise.study();</span><br><span class="line">        execise.age();</span><br><span class="line"></span><br><span class="line">       <span class="built_in"> User user </span>= new User();</span><br><span class="line">        </span><br><span class="line">        user.setPassword(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法的方法名必须和类名保持一致</p><p>如果自己定义了一个类的构造方法，那么如果像这样<br>    User user = new User();<br>系统就不管了，就要自己重新定义。</p><p>this关键字表示创建好的对象</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>GB collection垃圾回收机制</p><p>我们提前说下比较有意思一个故事，C++和java对比最头疼的就是内存管理需要程序员自己去解决。但是java有了垃圾回收器，解决了这个问题。</p><p>C++就像学校的食堂，java就像外面的餐馆。</p><p>垃圾回收器发现垃圾，算法大致了解一下(1)可达法和(2)引用计数法<br>但是引用计数法有个缺陷就是两个对象之间循环引用。</p><p>我建议在垃圾回收的过程也画一遍图</p><p>maniro major full gc</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>创建对象分为四步</p><ol><li>分配对象空间，并将对象成员变量初始化为0或空。</li><li>执行属性值的显示初始化。</li><li>执行构造方法。</li><li>返回对象的地址给相关变量。</li></ol><h2 id="和-equal"><a href="#和-equal" class="headerlink" title="== 和 equal"></a>== 和 equal</h2><p>记住一点就可以，基本类型可以看作最简单的类型，用哪个都可以比较<br>但是想一下，涉及一个对象的话，==号就失效了。为什么呢&gt;比较的是地址hascode，两个对象的hashcode是不一样的，一般常用的object类都重写了equal的方法。equal可以比较他们的内容。所以在撸码中，非要比较两个对象是否相等，那就重写这个类的equal方法。比较里面的某一个参数是否相等。</p><p>两个对象的地址不一致。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>对像类中的封装不要暴露给外面使用，一般会设置为private。</p><p>我们看看集中访问权限：private、default、protected、public</p><p>同一个类-&gt;同一个包-&gt;子类-&gt;全局</p><p>不管三七二十一，类中属性变量都私有。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我们去调一个方法，参数不同，行为不同。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组其实也是一个对象，记住里面对应每一个组标的数据可以看作是对象的成员变量。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final修饰的方法不能重写、类不能继承、修饰字符串则为字符串常量。</p><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>`<br>   public static void main(String[] args) {</p><pre><code>    String abc = &quot;hello java&quot;;    String def = &quot;HELLo java&quot;;    System.out.println(abc.substring(0, 9));    System.out.println(abc == def);    System.out.println(abc.equalsIgnoreCase(def));    System.out.println(abc.replaceAll(&quot;java&quot;,&quot;asd&quot;));    System.out.println(abc.compareTo(&quot;123&quot;));    String[] array = {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;};    System.out.println(JSON.toJSONString(testDeleteArrayOfIndex(array, 0)));    System.out.println(ArrayUtils.toString(testInsertArrayOfIndex(array, 1,2)));}/** * 删除指定数组元素 * @param array * @param index * @return */public static String[] testDeleteArrayOfIndex(String[] array, Integer index){</code></pre><p>//        String[] array2 = new String[array.length -1];<br>        System.arraycopy(array,index+1 , array, index, array.length - index  -1);<br>        array[array.length -1 ] = null;<br>        return array;</p><pre><code>}public static String[] testInsertArrayOfIndex(String[] array, Object param, Integer index){</code></pre><p>//        String[] array2 = new String[array.length -1];<br>        array = extendArray(array, 1);<br>        System.out.println(array.length);<br>        System.arraycopy(array, index , array, index+1, array.length-index - 1);<br>        array[index] = param.toString();<br>        return array;</p><pre><code>}/** * 数组扩容 * @param array * @param length * @return */public static String[] extendArray(String[] array, Integer length){    String[] s1 = {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;};    String[] s2 = new String[s1.length + length];    System.arraycopy(s1, 0 , s2, 0, s1.length);    return s2;}`</code></pre><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>`   public static void main(String[] args) {</p><pre><code>    String[] array = {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;};    System.out.println(midSort(array, &quot;6&quot;));}public static int midSort(String[] array, String value){    int left = 0;    int right = array.length - 1;    while ( left &lt;= right){        int mid = (left + right)/2 ;        if(array[mid].equals(value)){            return mid;        }        if(Integer.valueOf(value) &gt; Integer.valueOf(array[mid])){            left = mid+1;        }        if(Integer.valueOf(value) &lt; Integer.valueOf(array[mid])){            right = mid-1;        }    }    return  -1;}</code></pre><p>`</p><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>`<br>    public static void main(String[] args) {<br>        List<string> list01 = new ArrayList&lt;&gt;();<br>        list01.add(“01”);<br>        list01.add(“02”);<br>        list01.add(“03”);<br>        List<string> list02 = new ArrayList&lt;&gt;();<br>        list02.add(“01”);<br>        list02.add(“02”);<br>        list02.add(“04”);<br>        list02.add(“05”);<br>        list01.removeAll(list02);<br>        System.out.println(list01);</string></string></p><pre><code>    System.out.println(list01);}</code></pre><p>`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java集合、java并发、java网络、java虚拟机&lt;/p&gt;
&lt;p&gt;面向对象是java的一句代表&lt;/p&gt;
&lt;p&gt;面向对象的特征？四点记住！封装、继承、多态、抽象。&lt;/p&gt;
&lt;h2 id=&quot;面向对象—封装&quot;&gt;&lt;a href=&quot;#面向对象—封装&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://www.nouyc.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>我是菜鸟---java基础类型篇</title>
    <link href="https://www.nouyc.com/2019/05/14/%E6%88%91%E6%98%AF%E8%8F%9C%E9%B8%9F-java%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://www.nouyc.com/2019/05/14/我是菜鸟-java基础篇/</id>
    <published>2019-05-14T14:45:09.000Z</published>
    <updated>2019-05-17T03:06:46.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="局部变量、全局变量、静态变量的意思和生命周期"><a href="#局部变量、全局变量、静态变量的意思和生命周期" class="headerlink" title="局部变量、全局变量、静态变量的意思和生命周期"></a>局部变量、全局变量、静态变量的意思和生命周期</h2><p>注意点：局部变量是必须赋值才能使用，全局变量即使不赋值也有默认值，静态变量是全局的生命周期最长。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>只要给的值就不能再改变了，int age = 1；1是常量，age是变量。final 修饰的字符又是字符常量final int age。</p><h2 id="基本数据类型（primitive-data）"><a href="#基本数据类型（primitive-data）" class="headerlink" title="基本数据类型（primitive data）"></a>基本数据类型（primitive data）</h2><pre><code>                ----数值型 整数类型（byte、short、int、long）浮点类型(float、double)  （3大类、8小类）----基本数据类型  ----字符型 char 2个字节                ----布尔型 boolean 1位  注意⚠️ 一个bit</code></pre><p>数据类型</p><pre><code>----引用数据类型 类、接口、数组 占用4个字节。代表对象地址</code></pre><h2 id="整型变量-常量"><a href="#整型变量-常量" class="headerlink" title="整型变量/常量"></a>整型变量/常量</h2><p>byte、short、int、long</p><p>十进制正常数字、八进制015、十六进制0X16、二进制0b1101;</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>float、double</p><p>float a = 3.14F; double b = 1.14;浮点数是不精确的 ，一定不要用做比较。如果想比较浮点数，要用java.math包下面的BigDecimal和BigInteger</p><p>BigDecimal.valueOf(0.01);</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>true and false</p><h2 id="顺序结构、选择结构、循环结构"><a href="#顺序结构、选择结构、循环结构" class="headerlink" title="顺序结构、选择结构、循环结构"></a>顺序结构、选择结构、循环结构</h2><p>这节其实很易懂，但很多人忽略了，一个很小很小的程序，或者大的操作系统说白了都是变量+选择结构+循环结构组成的。</p><h2 id="break、continue"><a href="#break、continue" class="headerlink" title="break、continue"></a>break、continue</h2><p>break跳出整套循、continue跳出本次循环。另外还有带标签的break、continue。这个是可以跳转的。<br>之前有个goto关键字，是java一个保留字读。如果大量使用goto语句，程序结构可能会失去控制。所以我们使用带标签的break和continue。</p><p>场景：希望在一个嵌套循环中，跳出到外侧循环，</p><p>outer:<br>for（）{<br>    if(){<br>    break outer;<br>}<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;局部变量、全局变量、静态变量的意思和生命周期&quot;&gt;&lt;a href=&quot;#局部变量、全局变量、静态变量的意思和生命周期&quot; class=&quot;headerlink&quot; title=&quot;局部变量、全局变量、静态变量的意思和生命周期&quot;&gt;&lt;/a&gt;局部变量、全局变量、静态变量的意思和生命
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://www.nouyc.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础复习---jvm的几大分区和oom的情况</title>
    <link href="https://www.nouyc.com/2019/05/13/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-jvm%E7%9A%84%E5%87%A0%E5%A4%A7%E5%88%86%E5%8C%BA%E5%92%8Coom%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <id>https://www.nouyc.com/2019/05/13/java基础复习-jvm的几大分区和oom的情况/</id>
    <published>2019-05-13T02:57:21.000Z</published>
    <updated>2019-05-15T06:30:33.735Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java基础" scheme="https://www.nouyc.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>豪猪熔断器</title>
    <link href="https://www.nouyc.com/2019/05/04/%E8%B1%AA%E7%8C%AA%E7%86%94%E6%96%AD%E5%99%A8/"/>
    <id>https://www.nouyc.com/2019/05/04/豪猪熔断器/</id>
    <published>2019-05-04T05:38:44.000Z</published>
    <updated>2019-05-05T02:12:25.983Z</updated>
    
    <content type="html"><![CDATA[<p>熔断器的思想和我们日常所用的保险丝一样，是一款保护全局服务正常调用的工具，防止服务雪崩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;熔断器的思想和我们日常所用的保险丝一样，是一款保护全局服务正常调用的工具，防止服务雪崩。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.nouyc.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
