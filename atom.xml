<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nou的技术逆袭</title>
  <icon>https://www.gravatar.com/avatar/437514e75b4c3fbc3705e56df986d682</icon>
  <subtitle>无所谓挑战、情怀无限</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.nouyc.com/"/>
  <updated>2019-05-03T09:54:24.796Z</updated>
  <id>https://www.nouyc.com/</id>
  
  <author>
    <name>Nou</name>
    <email>709824656@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ribbon</title>
    <link href="https://www.nouyc.com/2019/05/02/Ribbon/"/>
    <id>https://www.nouyc.com/2019/05/02/Ribbon/</id>
    <published>2019-05-02T08:39:45.000Z</published>
    <updated>2019-05-03T09:54:24.796Z</updated>
    
    <content type="html"><![CDATA[<p>Ribbon的概念，实现客户端的软件式负载均衡。</p><p>负载均衡概念：集中式LB （F5）硬件层面 和 进程式LB软件层面。</p><h2 id="Ribbon配置初步"><a href="#Ribbon配置初步" class="headerlink" title="Ribbon配置初步"></a>Ribbon配置初步</h2><p> 正确的思维和落地方法论。</p><ol><li>GAV-maven</li><li><p>@Enable***</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable">@Configuration</span></span><br><span class="line">public class webConfig &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    <span class="variable">@LoadBalanced</span></span><br><span class="line">    public RestTemplate getRestTemplate()&#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Ribbon和eureka整合后，consumer可以直接调用不用再关心地址和端口号。</p><h2 id="Ribbon的负载均衡"><a href="#Ribbon的负载均衡" class="headerlink" title="Ribbon的负载均衡"></a>Ribbon的负载均衡</h2><p>默认轮询算法</p><p>配置多个eureka+多个消费+多个注册。每个注册独有DB。</p><h2 id="Ribbon核心组件IRule"><a href="#Ribbon核心组件IRule" class="headerlink" title="Ribbon核心组件IRule"></a>Ribbon核心组件IRule</h2><p>在configuration</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">webConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RadomRobinRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据特定算法选出来一个负载算法。</p><h2 id="Ribbon自定义"><a href="#Ribbon自定义" class="headerlink" title="Ribbon自定义"></a>Ribbon自定义</h2><p>自定义配置类，配置类不要放在compent的同目录下面。在启动类上面打@RobinClient(“微服务名称”,Rule.class)</p><p>在配置类中的，重新new一个实现了负载算法的实例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ribbon的概念，实现客户端的软件式负载均衡。&lt;/p&gt;
&lt;p&gt;负载均衡概念：集中式LB （F5）硬件层面 和 进程式LB软件层面。&lt;/p&gt;
&lt;h2 id=&quot;Ribbon配置初步&quot;&gt;&lt;a href=&quot;#Ribbon配置初步&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.nouyc.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>通读mysql的（持续更新）</title>
    <link href="https://www.nouyc.com/2019/05/01/%E9%80%9A%E8%AF%BBmysql%E7%9A%84%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://www.nouyc.com/2019/05/01/通读mysql的（持续更新）/</id>
    <published>2019-05-01T09:26:07.000Z</published>
    <updated>2019-05-01T17:01:41.876Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名工程师，不论前端后端，不熟悉甚至不了解mysql，真的很失败。本篇是持续更新篇，也是给自己一个复习空间。</p><h2 id="2019年5月1日—mysql的逻辑架构"><a href="#2019年5月1日—mysql的逻辑架构" class="headerlink" title="2019年5月1日—mysql的逻辑架构"></a>2019年5月1日—mysql的逻辑架构</h2><p>一些基本概念吧，上学的时候并不想背这些，其实怪自己没有下功夫去实践，实践几遍，不用背也能说出个123。<br>ACID、数据库的并发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名工程师，不论前端后端，不熟悉甚至不了解mysql，真的很失败。本篇是持续更新篇，也是给自己一个复习空间。&lt;/p&gt;
&lt;h2 id=&quot;2019年5月1日—mysql的逻辑架构&quot;&gt;&lt;a href=&quot;#2019年5月1日—mysql的逻辑架构&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="mysql" scheme="https://www.nouyc.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://www.nouyc.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>hadoop分布式的节操安装实践</title>
    <link href="https://www.nouyc.com/2019/04/29/hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E8%8A%82%E6%93%8D%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.nouyc.com/2019/04/29/hadoop分布式的节操安装实践/</id>
    <published>2019-04-29T02:11:47.000Z</published>
    <updated>2019-04-29T05:38:49.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算.本教程将指导如何用苹果macOS系统安装Hadoop。</p><h2 id="安装介绍"><a href="#安装介绍" class="headerlink" title="安装介绍"></a>安装介绍</h2><p>此篇来点真格的安装过程，可以按照流程走一遍，少走很多安装的大坑…..我当时安装了几乎小半个月，哎。菜是原罪….</p><p>另外，为什么说这是hadoop的分布式的节操呢？以下我分三块来说，例如hadoop的单机模式（流氓模式）、hadoop伪分布式模式（无赖模式）、hadoop完全分布式模式（正经人）。</p><p>这三种模式其实都是hadoop，就是我们安装的方式不一样。</p><h2 id="流氓三剑客"><a href="#流氓三剑客" class="headerlink" title="流氓三剑客"></a>流氓三剑客</h2><p>单机模式（standalone）</p><p>单机模式是Hadoop的默认模式。这种模式在一台单机上运行，没有分布式文件系统，而是直接读写本地操作系统的文件系统。当首次解压Hadoop的源码包时，Hadoop无法了解硬件安装环境，便保守地选择了最小配置。在这种默认模式下所有3个XML文件均为空。当配置文件为空时，Hadoop会完全运行在本地。因为不需要与其他节点交互，单机模式就不使用HDFS，也不加载任何Hadoop的守护进程。该模式主要用于开发调试MapReduce程序的应用逻辑。</p><p>伪分布模式（Pseudo-Distributed Mode）</p><p>这种模式也是在一台单机上运行，但用不同的Java进程模仿分布式运行中的各类结点</p><p>  伪分布模式在“单节点集群”上运行Hadoop，其中所有的守护进程都运行在同一台机器上。该模式在单机模式之上增加了代码调试功能，允许你检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。</p><p> 全分布模式（Fully Distributed Mode）</p><p>   Hadoop守护进程运行在一个集群上。</p><h2 id="依靠无赖走天下"><a href="#依靠无赖走天下" class="headerlink" title="依靠无赖走天下"></a>依靠无赖走天下</h2><p>自古流氓怕圣人、圣人怕无赖。我们先摆平无赖再去当圣人。</p><p>无赖模式、不，是伪分布式模式的安装用一台单机就可以模拟，废话少说。安装！我是在mac上模拟的，安装器也是Homebrew、如果在Linux环境下，自行选择安装器哈，流程都是一样的。</p><ol><li>打开shell命令，直接上—brew install hadoop</li></ol><p>安装过程会提示重要的信息，如下：</p><p>$JAVA_HOME has been set to be the output of:<br>  /usr/libexec/java_home</p><p>Hadoop的安装需要配置JAVA_HOME，用 brew安装，就已经帮我们配置好了。Java_Home老铁们知道干啥的吧….不多说了啊，系统环境变量。</p><ol start="2"><li>测试hadoop安装是否成功</li></ol><p>分布式模式需要在多台电脑上面测试，这里只测试前面两种，即单机模式和伪分布式模式。走一遍hadoop的mapReduce任务吧，一个基础操作就是输入输出。在hadoop的安装目录中，我的是这个/usr/local/Cellar/hadoop/3.1.1/libexec/share/hadoop/mapreduce。<br><img src="/2019/04/29/hadoop分布式的节操安装实践/hadoop自带jar包.jpg" alt><br>看见里面的client-jar包了吧，ok，我们到 cd /usr/local/Cellar/hadoop/3.1.1/<br>创建input和output目录<br><img src="/2019/04/29/hadoop分布式的节操安装实践/创建目录.jpg" alt><br>进入input目录 cd input，创建两个文件 echo ‘hello world’ &gt; file1.txt 、echo ‘hello hadoop’ &gt; file2.txt。<br><img src="/2019/04/29/hadoop分布式的节操安装实践/echo.jpg" alt></p><p>运行示例检测单机模式,在shell上直接走！</p><p>hadoop jar ./libexec/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.1.jar wordcount ./input ./output</p><p>显示结果<br>more output/part-r-00000   —- hadoop 1 hello 2 world 1</p><h2 id="进阶无赖"><a href="#进阶无赖" class="headerlink" title="进阶无赖"></a>进阶无赖</h2><p>伪分布式要修改的hadoop的配置了，这些配置是很关键的，有时间的同学可以挖一挖。</p><ol><li>so，cd 到 /usr/local/Cellar/hadoop/3.1.1/libexec/etc/hadoop中 修改Core-site.xml这是hadoop和hdfs的核心配置，有些配置是公用的。</li></ol><p>修改为：<br>    <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;configuration&gt;</span></span><br><span class="line">    <span class="params">&lt;property&gt;</span></span><br><span class="line">        <span class="params">&lt;name&gt;</span>hadoop.tmp.dir<span class="params">&lt;/name&gt;</span></span><br><span class="line">        <span class="params">&lt;value&gt;</span><span class="meta-keyword">/usr/</span>local/Cellar<span class="meta-keyword">/hadoop/</span>hdfs/tmp<span class="params">&lt;/value&gt;</span></span><br><span class="line">        <span class="params">&lt;description&gt;</span>A base for other temporary directories<span class="params">&lt;/description&gt;</span></span><br><span class="line">    <span class="params">&lt;/property&gt;</span></span><br><span class="line">    <span class="params">&lt;property&gt;</span></span><br><span class="line">        <span class="params">&lt;name&gt;</span>fs.default.name<span class="params">&lt;/name&gt;</span></span><br><span class="line">        <span class="params">&lt;value&gt;</span>hdfs:<span class="comment">//localhost:9000&lt;/value&gt;</span></span><br><span class="line">    <span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;configuration&gt;</span></span><br></pre></td></tr></table></figure></p><p>s.default.name 保存了NameNode的位置，HDFS和MapReduce组件都需要用到它，这就是它出现在core-site.xml 文件中而不是 hdfs-site.xml文件中的原因</p><ol start="2"><li>修改mapred-site.xml.template</li></ol><p>修改为：<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:9010<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>hdfs-site.xml</li></ol><p>修改为：<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>变量dfs.replication指定了每个HDFS数据库的复制次数。 通常为3, 由于我们只有一台主机和一个伪分布式模式的DataNode，将此值修改为1。</p><p>hadoop namenode -format<br>./sbin/start-all.sh</p><p>用示例测试</p><p>估计圆周率PI的值</p><p>hadoop jar ./libexec/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.1.jar pi 2 5</p><p>运行结果</p><p>Estimated value of Pi is 3.60000000000000000000</p><h2 id="靠谱的一篇正经人，Hadoop完全分布式教程"><a href="#靠谱的一篇正经人，Hadoop完全分布式教程" class="headerlink" title="靠谱的一篇正经人，Hadoop完全分布式教程"></a>靠谱的一篇正经人，Hadoop完全分布式教程</h2><p>完全分布式和伪分布式区别就是集群的搭建，加入了zk的配置。具体流程其实不复杂。</p><p>相关文档：<a href="https://blog.csdn.net/sunqingok/article/details/87210767" target="_blank" rel="noopener">https://blog.csdn.net/sunqingok/article/details/87210767</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hadoop是一个由Apache基金会所开发的分布式系统基础架构。Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS
      
    
    </summary>
    
    
      <category term="大数据，hadoop" scheme="https://www.nouyc.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%8Chadoop/"/>
    
  </entry>
  
  <entry>
    <title>浅分析HDFS</title>
    <link href="https://www.nouyc.com/2019/04/28/%E6%B5%85%E5%88%86%E6%9E%90HDFS/"/>
    <id>https://www.nouyc.com/2019/04/28/浅分析HDFS/</id>
    <published>2019-04-28T07:37:46.000Z</published>
    <updated>2019-04-28T14:30:14.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>和大家说说我接触大数据的经历吧。在去年刚毕业的我，一脸懵逼的进了公司，当时所属我的一个标签就是<div>菜狗</div>。什么都是新的，什么也都是挑战的。更糟糕的是面对突入其来的压力，走了很多弯路。其实回想下陌生的恐惧支配了我大部分的经历。唯一的欣慰点是这样的压力促进了我加快学习。<br>压力和工作气氛稍有好转的几天后，一个叫做HBase的玩具交给了我，让我玩一玩。简要来说—</p><ol><li>目标 运用HBase把海量数据查询和写入搞定，代替传统的关系型数据库mysql，我们的mysql日均写入量百万。在接手的时候总库的量已经破了4亿。没错，你在一个亿量级的表里面找条数据（索引失效），你想想后果。其实可以避免索引失效的，具体什么场景我后续来说。</li><li>HBase属于新应用，怎么搞自己去看吧，我tm居然从服务端学了起来，虽然很浅读，但基本HBase架构读了一遍。数据流怎么走的也有了基础掌握，返回头才看client端。我们应用方属于c端，大数据部门原来替我们做了server的管理。（其实我觉得，服务端和客户端都要学，因为调优的参数应用要懂吧、实际业务难免要做业务补偿，比如旧的历史消息bulkload进HBase、安全机制）</li><li>实际业务需求，这里所说的就是我们不敢，甚至任何一家公司新运用HBase也不敢直接取代mysql的地位。但想用HBase，那怎么保留mysql和HBase平等地位呢？<br>欢迎留言探讨。</li><li>压测，我居然搞了jemeter接口测试，过程你懂的。其实HBase有专业的压测，支持多线程。YCSB！</li></ol><h2 id="HBase的基础—HDFS"><a href="#HBase的基础—HDFS" class="headerlink" title="HBase的基础—HDFS"></a>HBase的基础—HDFS</h2><p>大家不要被大数据搞晕了，其实没什么恐怖的，虽然学起来有些难度，HDFS是大数据存储的底层系统了，从这里我们可以了解到整个Hadoop生态圈，我们先搞定这个，再去玩HBase。进而玩起spark、sqoop、Flink。</p><h2 id="先给大家讲个故事"><a href="#先给大家讲个故事" class="headerlink" title="先给大家讲个故事"></a>先给大家讲个故事</h2><p>一次赵栋请客吃饭，他叫了二十多个人，忆江南并没有大桌，只能分小桌落座。so，众口难调，为了照顾大家，每桌都是自己点菜，赵栋也是忙前忙后，忙着了解大家都点了些啥，毕竟他要结账。<br>服务员一下子面对六桌，菜有点多，有些菜忘了上哪桌，赵栋也会告诉他们。吃着吃着，突然博英桌点的一道猪蹄汤进了一个苍蝇。赵栋说：“没事儿，隔壁桌也点了这个汤。我去给你盛一碗。”</p><p>吃完饭，大家都很开心，一起踏上去小竹签的路上… </p><p>你以为我在说废话，讲故事。这个故事就是HDFS的精髓！</p><h2 id="初识HDFS—分布式文件系统"><a href="#初识HDFS—分布式文件系统" class="headerlink" title="初识HDFS—分布式文件系统"></a>初识HDFS—分布式文件系统</h2><p>先不谈分布式，先说说文件系统：文件系统就是用来管理文件的一个系统，比如你今天送我的mac pro，我在命令行敲一个ls，就能看到当前目录的文件。就算你没有钱、没送我mac。没关系，你给我装一个linux系统，我运行ls出来的显示，同样是直观的文件系统。<br>文件系统官方来说是存储文件、管理文件，并且提供文件系统的crud。问题来了，这些文件存在哪？硬盘！</p><p>知道了吧，万事万物想要持久化都要必进硬盘，别跟我扯什么云….云最后去哪了。</p><p>单台机器，单个硬盘的场景。假设，我有一个文件（600G），但我的mac只有256G，我存个鬼。so，怎么办。有人跟我说加硬盘…你干点别的吧。<br>把这个文件拆开呀！！！我有钱，我有10台mac，那我就拆成10份。每份60G，完全可以放进单台256G的mac了。多台机器形成的系统就是分布式文件系统。那么这里又有一个问题，单台机器单台ls，多台机器每个都要ls吗？否，提供一个统一的查询接口，对使用者而言就像操作一台机器一样！这就是HDFS下的 hdfs dfs -ls ，命令的精髓。也就是分布式文件系统的意思。</p><h2 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h2><p>赵栋请吃饭，一下子来20多人，怎么可能坐一桌，拆啊！！！这不就是文件切片的一个意思么。大文件切块后分别存储在多台机器，然后提供统一的操作接口，是不是分布式文件系统hdfs也是挺简单的。</p><h2 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h2><p>我把文件分了这么多份，我想找一个文件所在位置。我怎么去找到确定的一台机器呢？有人说，遍历一遍所有机器….哈哈，这样就太慢了，而且效率很低，是一个o(n)的算法。还有啊，我们刚刚说一个文件分别存在几台机器上，假如其中一台机器坏了，那么这个文件就不能访问了？有人说，机器故障率是0.000001%，然后他就觉得没问题。他这样想属于正常思维，但是一点就是他说的是单台机器。我们有10000000台机器，每台机器的事故率如上，那么这套系统的事故率是多少呢？10%….哪有这么多台机器！？你问问阿里的工程师他们有多少台虚机、物理机….如果要存储PB级或者EB级的数据，成千上万台机器组成的集群是很常见的，所以说分布式系统比单机系统要复杂得多呀。</p><h2 id="潜在问题-1"><a href="#潜在问题-1" class="headerlink" title="潜在问题"></a>潜在问题</h2><h2 id="破壁1——上菜是溯源"><a href="#破壁1——上菜是溯源" class="headerlink" title="破壁1——上菜是溯源"></a>破壁1——上菜是溯源</h2><p>破壁者的使命都是从他们的宿愿说起，了解下HDFS架构至关重要，才能解决这些潜在问题。再回溯到刚才说的吃饭情景。</p><p>服务员上菜的同时，并不知道这是哪桌的菜，“what fuck！5桌人，我该问谁？”。只能问赵栋，菜都是赵栋点的</p><p><img src="/2019/04/28/浅分析HDFS/上菜.jpg" alt><br>同等，我们看看HDFS的架构图<br><img src="/2019/04/28/浅分析HDFS/HDFS架构图.jpg" alt><br>像不像…</p><p>自己类比下啊，你可以把每一桌看作是一个DataNode、每一道菜看成一个文件切片，服务员相当于Client。文件切片具体放到哪个文件中，要去NameNode中寻找。DataNode是真正存储数据的地方，NameNode相当于一个管理者master，它知道每一个DataNode的存储情况，client其实就是那个对外操作的统一接口。<br>讲到这，引申一下，服务员不管上菜（写数据），还是找哪桌的盘子空了（读数据）都要先去赵栋这里询问下，赵栋（NameNode）统一回复服务员。这样时间复杂度是O(1)。效率提升了不少。</p><h2 id="破壁2——掉进猪蹄汤的苍蝇"><a href="#破壁2——掉进猪蹄汤的苍蝇" class="headerlink" title="破壁2——掉进猪蹄汤的苍蝇"></a>破壁2——掉进猪蹄汤的苍蝇</h2><p>假如说某一个DataNode坏了怎么办？像我刚才说的坏了一台机器。再类比吃饭什么情景呢？对，苍蝇掉进了猪蹄汤里。这一桌的人都不想动筷了，但又对这些美食抗拒不住。其他桌有相同的菜啊！这桌人全部去了隔壁桌….</p><p>听到这里，有没有发现什么。没错，hdfs在写入一个数据块的时候，不会仅仅写入一个DataNode，而是会写入到多个DataNode中，这样，如果其中一个DataNode坏了，还可以从其余的DataNode中拿到数据，保证了数据不丢失。多数据备份不仅在这里体现，大数据生态里面有很多也用到了这样的做法，例如kafka的多数据备份，但是都要分布在不同的机器上，保证一台机器挂了，可以在其他机器节点上找到数据。这样对存储空间的要求就很大，现在SSD都降价了，别说你的存储空间不够用。</p><h2 id="破壁3——上菜都是服务员的事儿"><a href="#破壁3——上菜都是服务员的事儿" class="headerlink" title="破壁3——上菜都是服务员的事儿"></a>破壁3——上菜都是服务员的事儿</h2><p>服务员把美食从后厨端过来的时候，就已经知道要把四盘一样的菜轮番上到不同的四桌。这里代表数据分片已经由Client端做了。</p><p><img src="/2019/04/28/浅分析HDFS/切片.jpg" alt></p><h2 id="破壁4——-一套完整的酒席"><a href="#破壁4——-一套完整的酒席" class="headerlink" title="破壁4—— 一套完整的酒席"></a>破壁4—— 一套完整的酒席</h2><p>从服务员上菜分桌，到同学们吃饭，再到离场撤盘子。这一套完整的酒席，就是HDFS一套完整的交互，流读取。<br>HDFS查询：<br><img src="/2019/04/28/浅分析HDFS/一套完整的酒席.jpg" alt></p><p>HDFS读取：<br><img src="/2019/04/28/浅分析HDFS/一套完整的酒席2.jpg" alt></p><p>写入这里有个问题，就是我们之前说的多数据备份问题。这里不能交给Client做，那不得累死服务员，由同学们自己安排就好了。也就是采用目前比较流行的binlog方法。mysql读写分离也采用这个方法，mysql转数据仓库也用binlog。DataNode之间自己同步，效率有很大提升。服务员只专心上菜。</p><p>中间难免的小插曲，比如说赵栋出去接电话，他这一个NameNode不在了（Down机），服务员正好来上菜。怎么办？所以只能准备多个NameNode，也就是NameNode集群，选举Master进行更替。如果只有一个赵栋的话，出现不在场行为，这酒席进行不下去了。必备的NameNode是必要的。NameNode中存储了整个系统的元数据metadata，是指描述数据的数据，这里指描述文件的数据，比如文件路径，文件被分为几块？每个块在哪些DataNode上等。</p><p>假如所有NameNode都要重启怎么办？防止这种情况，可以持久化到硬盘上啊，重启之后再从硬盘把数据恢复到内存不就行了？那要把所有数据都先写一遍硬盘、再重启后读一遍硬盘、每个metadata都要访问一遍….想想效率问题。HDFS采用WAl思想，所有的写入行为都被追踪到了日志中，一旦系统重启，恢复这个wal日志行为到重启前的样子就可以。</p><p>那WAL这个日志行为你想想跑了几个月有多大，一旦重启…还要回溯到几个月前的行为再来一遍写入吗？不现实。所以hdfs的设计者也想到了这个问题。你看看之前hdfs的架构图，里面有一个SecondNameNode，就是用来解决这个问题。</p><p>刚刚其实只说了一半，NameNode确实会回放editlog，但是不是每次都从头回放，它会先加载一个fsimage，这个文件是之前某一个时刻整个NameNode的文件元数据的内存快照，然后再在这个基础上回放editlog，完成后，会清空editlog，再把当前文件元数据的内存状态写入fsimage，方便下一次加载。<br><img src="/2019/04/28/浅分析HDFS/WAL.jpg" alt><br>一句话，简单来说全量导入变成了增量导入。</p><p>WAL只是解决了不全部回追数据的问题，NameNode还是很大的问题没有解决。SecondNameNode出场，他会定期将WAL日志存入fsimage中，然后清空WAL日志，就相当于跑个定时。<br>刚才说的，主NameNode挂了，集群中另一个NameNode顶上，可不是这个SecondNameNode啊，完全两回事。<br><img src="/2019/04/28/浅分析HDFS/second行为.jpg" alt></p><h2 id="破壁4—相爱相杀的Master和Active"><a href="#破壁4—相爱相杀的Master和Active" class="headerlink" title="破壁4—相爱相杀的Master和Active"></a>破壁4—相爱相杀的Master和Active</h2><p>hadoop2.x之前，整个集群只能有一个NameNode，是有可能发生单点故障的，所以hadoop1.x有本身的不稳定性。但是hadoop2.x之后，我们可以在集群中配置多个NameNode，就不会有这个问题了，但是配置多个NameNode，需要注意的地方就更多了，系统就更加复杂了。Hadoop1.0也想到了系统的稳定性，但这和系统的设计理念是有关系的，虽然hadoop1.x存在一个NameNode单点，但是它大大简化了系统的复杂度，并且数据量在一定范围内时，NameNode并没有这么容易挂，所以那个时代是被接受的。但是随着数据量越来越大，这个单点始终是个隐患，所以设计者不得不升级为更加复杂的hadoop2.x，来保证NameNode的高可靠。俗话说一山不容二虎，两个NameNode只能有一个是活跃状态active，另一个是备份状态standby，我们看一下两个NameNode的架构图。<br><img src="/2019/04/28/浅分析HDFS/主备切换.jpg" alt></p><p>变的复杂了吧，多看几遍就会了。active的NameNode挂了之后，standby的NameNode要马上接替它，所以它们的数据要时刻保持一致，在写入数据的时候，两个NameNode内存中都要记录数据的元信息，并保持一致。这个JournalNode就是用来在两个NameNode中同步数据的，并且standby NameNode实现了SecondNameNode的功能。<br>注意，hadoop2.x如果只部署一个NameNode，还是会用SecondNameNode。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试常考的！！！</p><p>HDFS优缺点：hdfs可以存储海量数据，并且是高可用的，任何一台机器挂了都有备份，不会影响整个系统的使用，也不会造成数据丢失。HDFS不适合存大批量的小文件，每一个小文件都有元信息，它们都存在NameNode里面，可能造成NameNode的内存不足。HDFS设计之初就是为了存储，不实用与编辑。所以，控制好你的业务方向…随机读写的效率很低。</p><p>1、hdfs是一个分布式文件系统，简单理解就是多台机器组成的一个文件系统。</p><p>2、hdfs中有3个重要的模块，client对外提供统一操作接口，DataNode真正存储数据，NameNode协调和管理数据，是一个典型的master-slave架构。</p><p>3、hdfs会对大文件进行切块，并且每个切块会存储备份，保证数据的高可用，适合存储大数据。</p><p>4、NameNode通过fsimage和editlog来实现数据恢复和高可用。</p><p>5、hdfs不适用于大量小文件存储，不支持并发写入，不支持文件随机修改，查询效率大概在秒级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;和大家说说我接触大数据的经历吧。在去年刚毕业的我，一脸懵逼的进了公司，当时所属我的一个标签就是&lt;div&gt;菜狗&lt;/div&gt;。什么都是新的，什么
      
    
    </summary>
    
      <category term="大数据" scheme="https://www.nouyc.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="HDFS" scheme="https://www.nouyc.com/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>羊APP产品思路</title>
    <link href="https://www.nouyc.com/2019/04/27/%E7%BE%8AAPP%E4%BA%A7%E5%93%81%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.nouyc.com/2019/04/27/羊APP产品思路/</id>
    <published>2019-04-27T08:13:04.000Z</published>
    <updated>2019-04-27T08:22:23.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产品构建"><a href="#产品构建" class="headerlink" title="产品构建"></a>产品构建</h2><p>   依托现有线下产品商户，做到产业链依托。我方提供互联网品牌、互联网营销链路、2B、2C、2O。</p><h2 id="产品遐想"><a href="#产品遐想" class="headerlink" title="产品遐想   "></a>产品遐想   </h2><p>众人养只羊，众人火锅—羔羊出生时，挂牌取名（这点很重要，我很看众情怀化的东西），吃有身份的羊！。羔羊在成长过程中，用户以每日喂料每日饲养为过程，让用户在网站上看到是自己的当院养的自己的羊。</p><p>自己当院的概念，后期做成自己的牧场，每人交牧场服务费。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;产品构建&quot;&gt;&lt;a href=&quot;#产品构建&quot; class=&quot;headerlink&quot; title=&quot;产品构建&quot;&gt;&lt;/a&gt;产品构建&lt;/h2&gt;&lt;p&gt;   依托现有线下产品商户，做到产业链依托。我方提供互联网品牌、互联网营销链路、2B、2C、2O。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Young羊" scheme="https://www.nouyc.com/tags/Young%E7%BE%8A/"/>
    
  </entry>
  
  <entry>
    <title>一次生动的TCP3次握手和4次挥手</title>
    <link href="https://www.nouyc.com/2019/04/26/%E7%94%9F%E5%8A%A8%E7%9A%84%E4%B8%80%E6%AC%A1TCP3%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://www.nouyc.com/2019/04/26/生动的一次TCP3次握手和4次挥手/</id>
    <published>2019-04-26T02:59:56.000Z</published>
    <updated>2019-04-26T03:50:04.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TCP握手挥手过程很简单，并不复杂。问题是记了忘，忘了记。以此循环，地老天荒。本渣还是决定用简单的描述手码一遍握手挥手的过程。<br>师弟师妹们也可以清楚一下零散的知识点。</p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>TCP三次握手就好比两个人在街上隔着一条大街互相瞅了一眼（别担心，这就是发生在东北），但是因为天儿不好，这俩人不能确定是否是心里的那个他，没法直接交手。<br>只能尴尬的先招手确定下对方是否认识自己。重点来了！！！刘能首先向赵四招手（syn），赵四看到刘能向自己招手，嘴角撇了撇。刘能看到赵四嘴角撇了，确认了赵四成功辨认出了自己(进入estalished状态)。但是赵四还有点狐疑，向四周看了一看，有没有可能刘能是在看别人呢，他也需要确认一下。所以赵四也向刘能招了招手(syn)，刘能看到赵四向自己招手后知道对方是在寻求自己的确认，于是也学着嘴角撇了撇(ack)，赵四看到对方的撇嘴后确认了刘能就是在向自己打招呼(进入established状态)。<br>于是俩人加快步伐，走到了一起，相互拥抱，互喊“亲家！！！”。<br><img src="/2019/04/26/生动的一次TCP3次握手和4次挥手/TCP三次握手.jpg" alt><br>我们看到这个过程中一共是四个动作，刘能招手–赵四撇嘴–赵四招手–刘能撇嘴。其中赵四连续进行了2个动作，先是撇嘴(回复对方)，<br>然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时撇嘴(syn+ack)。于是四个动作就简化成了三个动作，刘能招手–赵四撇嘴并招手–刘能撇嘴。这就是三次握手的本质，中间的一次动作是两个动作的合并。<br>我们看到有两个中间状态，synsent和synrcvd，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的撇嘴。<br>synsent是主动打开方的「半打开」状态，synrcvd是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。</p><p>syn_sent: syn package has been sent<br>syn_rcvd: syn package has been received</p><h2 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h2><p>TCP 数据传输就是两个人隔空对话，差了一点距离，所以需要对方反复确认听见了自己的话。<br>刘能喊了一句话(data)，赵四听见了之后要向刘能回复自己听见了(ack)。<br>如果刘能喊了一句，半天没听到赵四回复，刘能就认为自己的话被大风吹走了，赵四没听见，所以需要重新喊话，这就是tcp重传。也有可能是赵四听到了刘能的话，但是赵四向刘能的回复被大风吹走了，以至于刘能没听见赵四的回复。刘能并不能判断究竟是自己的话被大风吹走了还是赵四的回复被大风吹走了，刘能也不用管，重传一下就是。</p><p>既然会重传，赵四就有可能同一句话听见了两次，这就是「去重」。「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了，用户层是不用关心的。</p><p>刘能可以向赵四喊话，同样赵四也可以向刘能喊话，因为tcp链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。</p><p>刘能虽然磕巴但话多，一说连说了八句话，赵四说话也费劲，这时候赵四可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量ack。但是刘能也不能一次性说了太多话，赵四的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是「TCP窗口大小」。</p><p>网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，刘能挥手(fin)——赵四伤感地撇嘴(ack)——赵四挥手(fin)——刘能伤感地撇嘴(ack)。</p><p>之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。刘能已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，赵四呢继续喊话。等待赵四累了，也不再说话了，超刘能挥了挥手，刘能伤感地撇嘴了一下，才彻底结束了。<br><img src="/2019/04/26/生动的一次TCP3次握手和4次挥手/TCP四次挥手.jpg" alt><br>上面有一个非常特殊的状态time_wait，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。</p><p>它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的time_wait状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。</p><p>它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。</p><p>同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。</p><p>4分钟就是2个MSL，每个MSL是2分钟。MSL就是maximium segment lifetime——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从finwait1状态直接进入到timewait状态，跳过了finwait_2状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP状态转换是一个非常复杂的过程，本文仅对一些简单的基础知识点进行了类比讲解。关于TCP的更多知识还需要读者去搜寻相关技术文章进入深入学习。如果读者对TCP的基础知识掌握得比较牢固，高级的知识理解起来就不会太过于吃力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;TCP握手挥手过程很简单，并不复杂。问题是记了忘，忘了记。以此循环，地老天荒。本渣还是决定用简单的描述手码一遍握手挥手的过程。&lt;br&gt;师弟师
      
    
    </summary>
    
    
      <category term="TCP" scheme="https://www.nouyc.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>破解数据库连接工具navicat（亲测可用）</title>
    <link href="https://www.nouyc.com/2019/04/25/%E7%A0%B4%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7navicat%EF%BC%88%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <id>https://www.nouyc.com/2019/04/25/破解数据库连接工具navicat（亲测可用）/</id>
    <published>2019-04-25T03:15:57.000Z</published>
    <updated>2019-04-25T03:24:57.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="破解步骤"><a href="#破解步骤" class="headerlink" title="破解步骤"></a>破解步骤</h2><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h2 id="1-最好下载Navicat-Premium-12版本，至于mac-还是-win-自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。"><a href="#1-最好下载Navicat-Premium-12版本，至于mac-还是-win-自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。" class="headerlink" title="1.最好下载Navicat Premium 12版本，至于mac 还是 win 自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。"></a>1.最好下载Navicat Premium 12版本，至于mac 还是 win 自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。</h2><h2 id="生成秘钥对"><a href="#生成秘钥对" class="headerlink" title="生成秘钥对"></a>生成秘钥对</h2><p>2.生成自己的RSA公钥私钥对<br>    （这里直接使用大神的密钥，也可以自己生成测试可以用）</p><p>这步与windows版破解相同，可以用open ssl工具生成，也可以使用其他工具生成，注意密钥是2048位的，PKCS#8格式<br>为了节省时间，可以使用我提供的一对密钥。<br>公钥：</p><p>—–BEGIN PUBLIC KEY—–<br>MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQB8vXG0ImYhLHvHhpi5FS3g<br>d2QhxSQiU6dQ04F1OHB0yRRQ3NXF5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJX<br>HtQVLXMRms+chomsQCwkDi2jbgUa4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEF<br>h0N89FV4yGLyDLr+TLqpRecg9pkPnOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZS<br>I69sPD9xZRt+EciXVQfybI/2SYeAdXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd<br>+03NU3wvEmLBvGOmNGudocWIF/y3VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/p<br>AgMBAAE=<br>—–END PUBLIC KEY—–</p><p>私钥：</p><p>—–BEGIN RSA PRIVATE KEY—–<br>MIIEogIBAAKCAQB8vXG0ImYhLHvHhpi5FS3gd2QhxSQiU6dQ04F1OHB0yRRQ3NXF<br>5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJXHtQVLXMRms+chomsQCwkDi2jbgUa<br>4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEFh0N89FV4yGLyDLr+TLqpRecg9pkP<br>nOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZSI69sPD9xZRt+EciXVQfybI/2SYeA<br>dXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd+03NU3wvEmLBvGOmNGudocWIF/y3<br>VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/pAgMBAAECggEAK5qZbYt8wenn1uZg<br>6onRwJ5bfUaJjApL+YAFx/ETtm83z9ByVbx4WWT7CNC7fK1nINy20/mJrOTZkgIx<br>x6otiNC4+DIsACJqol+RLoo8I9pk77Ucybn65ZteOz7hVZIU+8j6LzW0KDt6yowX<br>e75r7G/NEpfibNc3Zz81+oDd2x+bHyGbzc9QcePIVuEzkof6jgpbWrQZU14itx9l<br>VxEgj/fbMccvBx8brR/l9ClmDZd9Y6TWsF1rfJpF3+DPeqFkKCiD7PGz3bs4O/Zd<br>ZrfV21ZNVusBW49G6bU63gQVKsOf1qGo3efbAW1HVxgTQ/lExVdcMvdenZm+ADKp<br>L4/wUQKBgQDOfBjn3OC2IerUFu18EgCS7pSjTSibXw+TeX3D5zwszLC091G2rGlT<br>5DihBUhMfesNdpoZynrs4YB6Sz9C3wSGAB8AM/tNvPhtSVtbMHmrdT2DEEKCvLkO<br>RNBnt+8aTu2hGRanw9aL1189gzwrmXK5ZuuURfgLrB9ihrvjo4VznQKBgQCapx13<br>dEA1MwapBiIa3k8hVBCoGPsEPWqM33RBdUqUsP33f9/PCx00j/akwmjgQNnBlAJo<br>Y7LOqPCyiwOkEf40T4IlHdzYntWQQvHhfBwqSgdkTE9tKj43Ddr7JVFRL6yMSbW3<br>9qAp5UX/+VzOLGAlfzJ8CBnkXwGrnKPCVbnZvQKBgQCd+iof80jlcCu3GteVrjxM<br>LkcAbb8cqG1FWpVTNe4/JFgqDHKzPVPUgG6nG2CGTWxxv4UFKHpGE/11E28SHYjb<br>cOpHAH5LqsGy84X2za649JkcVmtclUFMXm/Ietxvl2WNdKF1t4rFMQFIEckOXnd8<br>y/Z/Wcz+OTFF82l7L5ehrQKBgFXl9m7v6e3ijpN5LZ5A1jDL0Yicf2fmePUP9DGb<br>ZTZbbGR46SXFpY4ZXEQ9GyVbv9dOT1wN7DXvDeoNXpNVzxzdAIt/H7hN2I8NL+4v<br>EjHG9n4WCJO4v9+yWWvfWWA/m5Y8JqusV1+N0iiQJ6T4btrE4JSVp1P6FSJtmWOK<br>W/T9AoGAcMhPMCL+N+AvWcYt4Y4mhelvDG8e/Jj4U+lwS3g7YmuQuYx7h5tjrS33<br>w4o20g/3XudPMJHhA3z+d8b3GaVM3ZtcRM3+Rvk+zSOcGSwn3yDy4NYlv9bdUj/4<br>H+aU1Qu1ZYojFM1Gmbe4HeYDOzRsJ5BhNrrV12h27JWkiRJ4F/Q=</p><h2 id="—–END-RSA-PRIVATE-KEY—–"><a href="#—–END-RSA-PRIVATE-KEY—–" class="headerlink" title="—–END RSA PRIVATE KEY—–"></a>—–END RSA PRIVATE KEY—–</h2><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><p>3 安装程序，并替换应用包内容目录中rpk文件的公钥</p><h2 id="安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录-Contents-Resources，编辑rpk文件，将公钥替换并保存。"><a href="#安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录-Contents-Resources，编辑rpk文件，将公钥替换并保存。" class="headerlink" title="安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录 /Contents/Resources，编辑rpk文件，将公钥替换并保存。"></a>安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录 /Contents/Resources，编辑rpk文件，将公钥替换并保存。</h2><h2 id="算出有效的Mac版序列号密钥"><a href="#算出有效的Mac版序列号密钥" class="headerlink" title="算出有效的Mac版序列号密钥"></a>算出有效的Mac版序列号密钥</h2><p>4 使用我算好的密钥可以跳过此步，继续第四步，节省时间。<br>中文版64位密钥序列号： NAVH-T4PX-WT8W-QBL5</p><h2 id="英文版64位密钥序列号：-NAVG-UJ8Z-EVAP-JAUW"><a href="#英文版64位密钥序列号：-NAVG-UJ8Z-EVAP-JAUW" class="headerlink" title="英文版64位密钥序列号： NAVG-UJ8Z-EVAP-JAUW"></a>英文版64位密钥序列号： NAVG-UJ8Z-EVAP-JAUW</h2><h2 id="解密请求码，生成激活码"><a href="#解密请求码，生成激活码" class="headerlink" title="解密请求码，生成激活码"></a>解密请求码，生成激活码</h2><p>打开应用，断网！！！，点击注册，输入密钥 NAVH-T4PX-WT8W-QBL5，然后手动激活<br>复制请求码，使用私钥解密请求码，得到激活码明文<br>注意必须自己解密，因为解密后得到的“DI”是不同的<br>激活码明文示例：<br>{<br>  “K” : “NAVHT4PXWT8WQBL5”,<br>  “P” : “Mac 10.13”,<br>  “DI” : “ODQ2Yjg2ZDBjMTEzMjhh”<br>}<br>在线RSA私钥解密：<a href="http://tool.chacuo.net/cryptrsaprikey" target="_blank" rel="noopener">http://tool.chacuo.net/cryptrsaprikey</a></p><p>将得到的激活码明文进行修改，修改后格式如下<br>{“K”:”NAVHT4PXWT8WQBL5”, “N”:”52pojie”, “O”:”52pojie.cn”, “DI”:”ODQ2Yjg2ZDBjMTEzMjhh”, “T”:1516939200}<br>激活码明文格式最好复制我的，改变 “ “ 内的字符即可，在同一行哦，不要换行，否则激活失败！！！<br>“K” “DI” 都替换成自己机器解密的信息，”N” “O” “T”自己定义</p><p>加密激活码明文，使用私钥加密激活码明文<br>在线RSA私钥加密：<a href="http://tool.chacuo.net/cryptrsaprikey" target="_blank" rel="noopener">http://tool.chacuo.net/cryptrsaprikey</a></p><h2 id="复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活"><a href="#复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活" class="headerlink" title="复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活"></a>复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活</h2><h2 id="完整教程贴图地址"><a href="#完整教程贴图地址" class="headerlink" title="完整教程贴图地址"></a>完整教程贴图地址</h2><p><a href="https://blog.csdn.net/xhd731568849/article/details/79751188" target="_blank" rel="noopener">https://blog.csdn.net/xhd731568849/article/details/79751188</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;破解步骤&quot;&gt;&lt;a href=&quot;#破解步骤&quot; class=&quot;headerlink&quot; title=&quot;破解步骤&quot;&gt;&lt;/a&gt;破解步骤&lt;/h2&gt;&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://www.nouyc.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Rest微服务构建案例</title>
    <link href="https://www.nouyc.com/2019/04/24/Rest%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA%E6%A1%88%E4%BE%8B/"/>
    <id>https://www.nouyc.com/2019/04/24/Rest微服务构建案例/</id>
    <published>2019-04-24T13:41:03.000Z</published>
    <updated>2019-04-28T02:35:30.798Z</updated>
    
    <content type="html"><![CDATA[<p>记住一句话：约定 &gt; 配置 &gt; 编码<br>Rest微服务一个基础构建是整个微服务的一个基础，先说下总体介绍。</p><p>有以下几个部分：<br>             1.mvc、mybatis（一带而过了）<br>             2.maven（坐标、仓库、依赖、聚合、继承）。理论要熟练下。<br>               maven的命令：maven -U clean package install 这是我常用的，也是在更新了包所必备去更新到本地的命令。其他工程才能依赖最新的jar包。<br>               父工程包含很多子工程，子工程公用的依赖包可以提到父工程中。</p><h2 id="撸码"><a href="#撸码" class="headerlink" title="撸码"></a>撸码</h2><h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h2><p>   （一）构建父工程，分布式开发所必备的建工程流程。构建父工程要点就是maven 的打包packaging要为pom。goupId和artifactId都要起好，否则很容易混淆。<br>   构建完pom父工程后，新构建的pom中有几大几个部分—-<br>            1.头部<project xmlns*****（这个不用我多说了） 2.mark名（组名、项目名、版本号、packaging方式） 3.公共properties 4.dependency （二）构建公共子模块api,在所见父工程上右键鼠标选择new->(重要！)Other-&gt; Maven Moudle。goupId和artifactId都要起好还是一样的要起好，packaging这时侯<br>        变了！变成了jar包。在构建框里面的置灰部分，你也会看见parent的工程也就是上方所说的父工程。点击确定！<br>        创建完毕后，返回头去父工程的pom文件中查看下，发现新增<moudles><moudle>moudleName<moudle></moudle></moudle></moudles><br>        构建实体类的样子记得最好用工具lombok<br>        （1）@AllArgsConstructor<br>            @NoArgsConstructor<br>            @Data<br>            @Accessors(chain = true)<br>            public class entity {<br>                private Long id;<br>                private String msg;<br>                private String DBSource;<br>            }<br>        （2）在yml中配置我们所需要的配置信息，例：mybatis、spring日志config、重要的是spring-application-name！！！！暴露出去的微服务名称。<br>        （3）创建数据库genetator，自动生成mapper、entity、dao。<br>        （4）给数据库造点假数据。对了，这里数据库的库和表要自己建好，否则（3）进行不下去。这一步省去了你很多时间，真正提高工作效率。如何运用，请看管理系统标签<br>        （5）整合service层<br>        （6）整合controller层<br>            都在各层记得打@啊！！！</project></p><pre><code>添加主启动类：SpringApplication.run(所属类,args);启动！done</code></pre><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><p>   构建consumer过程和上方大部分一致，直到（5）部，不再调用service层进行数据库操作了。<br>   这里！！！！在controller中加入@Autowired RestTemplate restTemplate;<br>   操作—<br>           restTemplate.getForObject();//传参3个参数，请求服务的URL（provider的controller地址），传递参数（provider api 对应参数），返回类型（可选boollean、有很多）<br>        restTemplate.postForObject();//同上<br>        添加主启动类：SpringApplication.run(所属类,args);启动！done。实验下，发现consumer的调用直接调到了provider。</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka      "></a>Eureka      </h2><p>假如我们要引进clould一个新组件，将provider引入Eureka，基本上有两步<br>    1.新增Eureka依赖<br>    2.@EnableEurekaServer<br>    3.zuul<br>    4.业务逻辑<br>    5.注册中心/info/自定义ip/修改显示节点名称<br>    6.Eureka的自我保护，在server主页面上出现红色字体，注意这个不是报错。是server的一种监听机制。<br>    这里我们做个测试，我们频繁操作下provider配置文件下面的节点名称（instance id），会在server发现出现了上方的红色字体。自我保护机制：一句话，<br>    好死不如赖活着。server 会保留了我们抖动的节点名称。某一时刻某个微服务不可用了，Eureka它不会立刻清理，依旧对微服务的信息进行保存。<br>    应对网络异常的一种措施。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本期微服务的构建案例，总结其精髓就是rest api！同时也是和dubbo不同的所在。剩下搞过mvc开发的，熟悉其开发流程的同学来说，只是增添了一些小应用有没有，<br>当然这些都是构建在SpringBoot的基础上搞的，SpringBoot这个框架，本人是真的喜欢，但是喜欢的同时千万要对其自动配置、起步依赖、Actuator、命令行界面<br>要有深入理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记住一句话：约定 &amp;gt; 配置 &amp;gt; 编码&lt;br&gt;Rest微服务一个基础构建是整个微服务的一个基础，先说下总体介绍。&lt;/p&gt;
&lt;p&gt;有以下几个部分：&lt;br&gt;             1.mvc、mybatis（一带而过了）&lt;br&gt;             2.mave
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://www.nouyc.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>kafka的生产+消费</title>
    <link href="https://www.nouyc.com/2019/04/23/kafka%E7%9A%84%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9/"/>
    <id>https://www.nouyc.com/2019/04/23/kafka的生产-消费/</id>
    <published>2019-04-23T10:17:18.000Z</published>
    <updated>2019-04-23T13:38:33.656Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列的内容很丰富，目前我常用的是kafka，所以第一篇献给我的kafka，后续我们继续钻研下，RocketMQ、ActiveMQ。<br>kafka的原生写法，不繁琐，直接看见配置项就👌，如果你是刚入门大数据或者是刚接手kafka的话难免有蒙圈的感觉，But！！！这不要紧，先蒙在其中，后续你接触多了大数据的东西，就会发现，很多组件用了很多的配置项，加载进配置项就可以用了。当然我说的还是比较原生的写法，刚刚写完了一遍HBase的原生，一时脱离不出底层的范围哈哈哈。</p><h2 id="心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码"><a href="#心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码" class="headerlink" title="心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码"></a>心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码</h2><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>public class KafkaProvider{</p><pre><code>private final Producer&lt;String, String&gt; producer;public final static String TOPIC = &quot;TEST-TOPIC&quot;;public KafkaProvider(){    Properties props = new Properties();//配置项！这行代码是kafka的源头。    props.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:9092&quot;);//zookeeper地址，集群用逗号分隔      //这里如果不熟悉的同学，可以看看kafa的架构图。每一个      ![](kafka架构.jpg)    props.put(&quot;acks&quot;, &quot;all&quot;);//记录完整提交，最慢但是最大可能的持久化    props.put(&quot;retries&quot;, 3);//请求失败的重试次数    props.put(&quot;batch.size&quot;, 16384);//batch大小    props.put(&quot;linger.ms&quot;, 1);// 默认情况即使缓冲区有剩余的空间，也会立即发送请求，设置一段时间用来等待从而将缓冲区填的更多，单位为毫秒，producer发送数据会延迟1ms，可以减少发送到kafka服务器的请求数据    props.put(&quot;buffer.memory&quot;, 33554432);// 提供给生产者缓冲内存总量    props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);//写话方式    props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);    //生成生产者    producer =  new KafkaProducer&lt;String, String&gt;(props);}//在入口函数调用即可，具体应用情形根据项目实际来看public void producer(){    int messageNo = 1;    final int COUNT =1000;    while (1){        String num = String.valueOf(messageNo);        String data = &quot;hello kafka message:&quot; + num;        ProducerRecord record = new ProducerRecord(TOPIC,data);        producer.send(record);        messageNo ++ ;        System.out.println(messageNo);        try {            sleep(1000);        } catch ( InterruptedException e ) {            e.printStackTrace();        }    }}</code></pre><h2 id><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>public class KafkaConsumer {<br>    private final Consumer consumer ;<br>    public final static String TOPIC = “TEST-TOPIC”;<br>    private ExecutorService executors;</p><pre><code>public KafkaCon(){    Properties props = new Properties();    props.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:9092&quot;);//zk同生产者一致    props.put(&quot;group.id&quot;, &quot;2&quot;);//分组Id！！！！    props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);//自动提交，这是对offset的操作，有些需要对offset更加精准的处理，需要进行手动提交。    props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);    props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);    props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);    props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);    consumer = new KafkaConsumer&lt;String, String&gt;(props);    consumer.subscribe(Arrays.asList(TOPIC));    execute(10);}public void execute(int workerNum) {    executors = new ThreadPoolExecutor(workerNum, workerNum, 0L, TimeUnit.MILLISECONDS,            new ArrayBlockingQueue(1000), new ThreadPoolExecutor.CallerRunsPolicy());    Thread t = new Thread(new Runnable(){//启动一个子线程来监听kafka消息        @Override        public void run(){            while (true) {                ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);                for (final ConsumerRecord record : records) {                    System.out.println(&quot;【Kafka】监听到kafka的TOPIC【&quot; + record.topic() + &quot;】的消息&quot;);                    System.out.println(&quot;【Kafka】消息内容：&quot; + record.value());                    executors.submit(new ConsumerWorker(record));                }            }        }});    t.start();}</code></pre><p>}</p><p>这是标准的一个kafka配置信息，生产实战中的应用很简单，千万记住几个关键词：produce、consumer、topic、group.id、partition、broker，schema的含义，主要还是理解吧。<br>提几个问题哈？如果你想多个消费者消费一个topic怎么办？partion中的消息是顺序的，多个partion间的消息呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息队列的内容很丰富，目前我常用的是kafka，所以第一篇献给我的kafka，后续我们继续钻研下，RocketMQ、ActiveMQ。&lt;br&gt;kafka的原生写法，不繁琐，直接看见配置项就👌，如果你是刚入门大数据或者是刚接手kafka的话难免有蒙圈的感觉，But！！！这不
      
    
    </summary>
    
      <category term="kafka" scheme="https://www.nouyc.com/categories/kafka/"/>
    
    
      <category term="消息队列，kafka" scheme="https://www.nouyc.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8Ckafka/"/>
    
  </entry>
  
  <entry>
    <title>java 代码请求URl样例</title>
    <link href="https://www.nouyc.com/2019/04/23/java-%E4%BB%A3%E7%A0%81%E8%AF%B7%E6%B1%82URl%E6%A0%B7%E4%BE%8B/"/>
    <id>https://www.nouyc.com/2019/04/23/java-代码请求URl样例/</id>
    <published>2019-04-23T03:36:09.000Z</published>
    <updated>2019-04-23T04:45:44.373Z</updated>
    
    <content type="html"><![CDATA[<p>习惯了在开发中运用工具（postman等）调试接口，几乎忘了用代码可以更好的处理实际情况。</p><hr><p>Demo样例<br>    /**</p><pre><code> * 发送post请求 * @param url  路径 * @param jsonObject  参数(json类型) * @param encoding 编码格式 * @return * @throws ParseException * @throws IOException */public static String send(String url, JSONObject jsonObject,String encoding) throws ParseException, IOException{    String body = &quot;&quot;;    //创建httpclient对象    CloseableHttpClient client = HttpClients.createDefault();    //创建post方式请求对象    HttpPost httpPost = new HttpPost(url);    //装填参数    StringEntity s = new StringEntity(jsonObject.toString(), &quot;utf-8&quot;);    //参数体有按要求也要进行Content-type赋值    s.setContentType(&quot;application/json&quot;);    s.setContentEncoding(new BasicHeader(HTTP.CONTENT_TYPE,            &quot;application/json&quot;));    //设置参数到请求对象中    httpPost.setEntity(s);    System.out.println(&quot;请求地址：&quot;+url);</code></pre><p>//        System.out.println(“请求参数：”+nvps.toString());</p><pre><code>    //设置header信息    //指定报文头【Content-type】、【User-Agent】选择其一就ok    httpPost.setHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);    httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;);    httpPost.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;);    //执行请求操作，并拿到结果（同步阻塞）    CloseableHttpResponse response = client.execute(httpPost);    //获取结果实体    HttpEntity entity = response.getEntity();    if (entity != null) {        //按指定编码转换结果实体为String类型        body = EntityUtils.toString(entity, encoding);    }    EntityUtils.consume(entity);    //释放链接    response.close();    return body;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;习惯了在开发中运用工具（postman等）调试接口，几乎忘了用代码可以更好的处理实际情况。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Demo样例&lt;br&gt;    /**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * 发送post请求
 * @param url  路径
 * @param jsonOb
      
    
    </summary>
    
      <category term="HTTP" scheme="https://www.nouyc.com/categories/HTTP/"/>
    
    
      <category term="Http" scheme="https://www.nouyc.com/tags/Http/"/>
    
      <category term="SpringMVC" scheme="https://www.nouyc.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot深入剖析，够用了。</title>
    <link href="https://www.nouyc.com/2019/04/21/SpringBoot%E6%94%B9%E9%80%A0/"/>
    <id>https://www.nouyc.com/2019/04/21/SpringBoot改造/</id>
    <published>2019-04-21T08:52:10.000Z</published>
    <updated>2019-04-30T10:00:19.900Z</updated>
    
    <content type="html"><![CDATA[<p>刚入职的时候，发现我们接手项目是ssm和SpringBoot混用，这个”混用”听起来奇怪哈？一句话就是很多依赖项用了SpringBoot又用了原生，还用了ssm中的一些写法。直观看上去一句my god～～～<br>对新入职的应届生来说，多少会有混淆，用起来也会很撇脚（碍手？）。但本菜狗认为这真是一个学习的好机会，从最原生的写一遍，写到SpringBoot，写到地老天荒。另外悄悄告诉你，我们的之前组件都是原生的哈哈哈哈，根本没有Compent，你知道怎么实现的吗？</p><p>以上都是废话</p><hr><p>干货</p><p>我介绍下SpringBoot的原理，也偷偷抓紧复习下。—2019年4月21日</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>耽误了几天哈—2019年4月29日<br>本文不东扯西扯、只专注剖析SpringBoot。废话不多说，撸码！</p><p><img src="/2019/04/21/SpringBoot改造/一个标配的启动类.jpg" alt><br>这是一个已经建好的启动类，我用的编译器是IDEA，我也推荐各位用上这款软件，我只专注java开发哈，至于kotlin，Lua….我是没有用这个软件玩过。<br>至于这么到这一步，麻烦看下标签中题目：构建微服务实战的介绍，很简单。简单说两句吧，我用IDEA构建项目一般都是用在线化构建，很方便，可以选择很多starter。不过新手我建议这么做， 还是老老实实用在线化下方的maven模块去构建。具体什么原因，请看完本篇再翻过头想想。</p><p><img src="/2019/04/21/SpringBoot改造/新建第一步.jpg" alt></p><p><img src="/2019/04/21/SpringBoot改造/构建项目.jpg" alt></p><h2 id="自己造一个启动类"><a href="#自己造一个启动类" class="headerlink" title="自己造一个启动类"></a>自己造一个启动类</h2><p>在我们建好的工程中，添加一个启动函数，这个应该会吧？注意在入口函数上打上@SpringBootApplication，完整入口函数如下。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String []args) &#123;</span><br><span class="line">        SpringApplication.run(Main.<span class="keyword">class</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动！没问题。<br><img src="/2019/04/21/SpringBoot改造/SpringBoot启动.jpg" alt></p><h2 id="世界从-SpringBootApplication开始。"><a href="#世界从-SpringBootApplication开始。" class="headerlink" title="世界从@SpringBootApplication开始。"></a>世界从@SpringBootApplication开始。</h2><p>我刚让大家在启动类打上的@SpringBootApplication，为什么被称为世界的入口。来进入这个@看看。这里面讲解有点长啊，我建议大家坚持下，一口气读完，断断续续的读效果不好。我开始断断续续的看源码，效果真的差。</p><p><img src="/2019/04/21/SpringBoot改造/boot入口.jpg" alt></p><p>这里面有三个重要标签@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan。<br>即 @SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。</p><ol><li>@SpringBootConfiguratio<br>拿@SpringBootConfiguration来说，这里面其实就是要一个@Configuration的注解，来定义了这个Class为配置类。再引申来说@Configuration的作用，你暂且把它看成要往Spring注入实例的一个大门。</li></ol><p><img src="/2019/04/21/SpringBoot改造/configuration.jpg" alt></p><p>官方来说，javaConfig形式的ioc容器的配置类使用的都是@Configuration的注解。SpringBoot社区推荐javaConfig的配置形式。过去常写mvc的同学对javaConfig有点陌生哈，其实简单一句话就是把过去的xml的各种配置类，放进了代码中。有人就很反感这种，认为配置就是配置，代码就是代码啊，把配置融进代码反而复杂了感觉，我开始也这么认为。后来，我的表现….真香！</p><p>举几个简单例子回顾下，XML跟config配置方式的区别：</p><p>（1）表达形式层面：<br>    基于XML配置的方式是这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>而基于JavaConfig的配置方式是这样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span>&#123;</span></span><br><span class="line">    <span class="comment">//bean定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）注册bean定义层面<br>    基于XML的配置形式是这样：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"DubboService"</span> <span class="built_in">class</span>=<span class="string">"..DubboServiceImpl"</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>而基于JavaConfig的配置形式是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DubboService <span class="title">dubboService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DubboServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。也可以自己取名字，起名字按规范一般也都是方法名。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Bean</span>(<span class="keyword">name</span> = <span class="string">"dubboService"</span>)</span><br></pre></td></tr></table></figure><p>（3）表达依赖注入关系层面</p><pre><code>为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"DubboService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"..DubboServiceImpl"</span>&gt;</span><br><span class="line">   &lt;propery name =<span class="string">"dependencyService"</span> ref=<span class="string">"dependencyService"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br><span class="line"><span class="regexp">&lt;bean id="dependencyService" class="DependencyServiceImpl"&gt;&lt;/</span>bean&gt;</span><br></pre></td></tr></table></figure><p>而基于JavaConfig的配置形式是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DubboService <span class="title">dubboService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DubboServiceImpl(dependencyService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DependencyService <span class="title">dependencyService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DependencyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果一个bean的定义依赖其他bean，则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。Spring注入实例大门@Configuration，现在请记住他的搭档--@Bean，他们是一对的。我们来看一个完整的案例。</p><p>.xml的<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt; </span><br><span class="line">    &lt;bean <span class="built_in">id</span> = <span class="string">"car"</span> <span class="built_in">class</span>=<span class="string">"com.test.Car"</span>&gt; </span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"wheel"</span> <span class="keyword">ref</span> = <span class="string">"wheel"</span>&gt;&lt;/<span class="keyword">property</span>&gt; </span><br><span class="line">    &lt;/bean&gt; </span><br><span class="line">    &lt;bean <span class="built_in">id</span> = <span class="string">"wheel"</span> <span class="built_in">class</span>=<span class="string">"com.test.Wheel"</span>&gt;&lt;/bean&gt; </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Car car = <span class="keyword">new</span> Car(); </span><br><span class="line">        car.setWheel(wheel()); </span><br><span class="line">        <span class="keyword">return</span> car; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wheel <span class="title">wheel</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheel(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。<br>@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。</p><ol start="2"><li>@ComponentScan<br>这个注解在xml中也有同样体现，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义]、@Controller、@Service最终将这些bean定义加载到IoC容器中。<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span></span></span></span><br><span class="line"><span class="xml">    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">list</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="xml">          ...</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"url"</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"url"</span>/</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><p>如果不指定某一个扫描路径，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。所以这里面有个知识点，main启动类要在最根的目录上，会有组件扫描不进来的现象。</p><ol start="3"><li>@EnableAutoConfiguration<br>为什么这个@EnableAutoConfiguration我要放在最后说，这个是SpringBoot牛逼的体现，各位有没有之前在Spring上开启某些组件的，@Enable<em>**</em>等，@EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。@EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。<br>而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，其实核心意思是一个。我们进入@EnableAutoConfiguration这个注解中看看。</li></ol><p><img src="/2019/04/21/SpringBoot改造/import.jpg" alt><br>由于import的支持，SpringBoot得以收集了各类场景的组件的支持。@Import(AutoConfigurationImportSelector.class)，在这个import的类AutoConfigurationImportSelector.class中，可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样，借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！</p><p>来看看这个Boss—SpringFactoriesLoader藏的并不深。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getCandidateConfigurations(AnnotationMetadata metadata,</span><br><span class="line">AnnotationAttributes attributes) &#123;</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 SpringFactoriesLoader.loadFactoryNames 是关键。再进入一层看看。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="built_in">String</span> factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">List</span>)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; result = (MultiValueMap)cache.<span class="keyword">get</span>(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                <span class="built_in">Iterator</span> var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    <span class="built_in">String</span> factoryClassName = ((<span class="built_in">String</span>)entry.getKey()).trim();</span><br><span class="line">                    <span class="built_in">String</span>[] var9 = StringUtils.commaDelimitedListToStringArray((<span class="built_in">String</span>)entry.getValue());</span><br><span class="line">                    <span class="built_in">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        <span class="built_in">String</span> factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location [META-INF/spring.factories]"</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稳住别慌，到关键了！！！loadFactoryNames方法中的loadSpringFactories执行了这么一段<br>Enumeration<url> urls = classLoader != null ? classLoader.getResources(“META-INF/spring.factories”) : ClassLoader.getSystemResources(“META-INF/spring.factories”);</url></p><p>classLoader.getResources(“META-INF/spring.factories”)看到没，这个META-INF文件下的spring.factories内容中获取我们准备加载的class的URL，这个<br>META-INF就是再那spring.factories有什么呢？来睁大眼睛看！<br><img src="/2019/04/21/SpringBoot改造/springFactories.jpg" alt><br>神不神奇，所以，@EnableAutoConfiguration自动配置的魔法骑士就变成了：从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（JavaRefletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。从AutoConfiguration往下看，会看到很多自动配置的很多信息。有我们经常使用的种种比如这个</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.quartz</span><span class="selector-class">.QuartzAutoConfiguration</span>,\</span><br></pre></td></tr></table></figure><p>这是一个定时任务的自动配置项，我们进入这个类里看看<br>从@EnableConfigurationProperties(QuartzProperties.class)再进入QuartzProperties.class类中，发现注解项@ConfigurationProperties(“spring.quartz”)，这是什么啊？！这不就是，你在yml配置文件写入Spring.quartz所属的配置项了么，立图为证。<br><img src="/2019/04/21/SpringBoot改造/定时配置项.jpg" alt></p><p>所以一个EnableAutoConfiguration帮我们解决了很多事情，不用再引入一对properties了，只需要在yml（有的使用properties，我推荐使用yml）配置文件中，加上自己想要的配置参数就可以了。</p><h2 id="跟我来一遍SpringBoot的跑的流程"><a href="#跟我来一遍SpringBoot的跑的流程" class="headerlink" title="跟我来一遍SpringBoot的跑的流程"></a>跟我来一遍SpringBoot的跑的流程</h2><h2 id="run-方法—执行"><a href="#run-方法—执行" class="headerlink" title="run()方法—执行"></a>run()方法—执行</h2><p>说完我们启动类的三大注解我们再次回到我们的启动类哈哈哈！</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: microservicecloudprovider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Nou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-04-29 18:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String []args) &#123;</span><br><span class="line">        SpringApplication.run(Main.<span class="keyword">class</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SpringApplcation执行的run方法中，执行一个静态方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext run(<span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">primarySource</span>, <span class="title">String</span>... <span class="title">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="class"><span class="keyword">Class</span>[]</span>&#123;primarySource&#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new Class[]{primarySource}, args —new 出了一个Spring的实例，然后直接调用这个实例。在初始化的时候，SpringBoot会提前干这么几件事。</p><ol><li>在类路径下（classPath）面找下是否有org.springframework.web.context.ConfigurableWebApplicationContext这个类，这是创建web环境的准备。是否创建一个为web准备的ApplicationContext类。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。<br>以上两个也就是我刚才圈出来的启动项，联系起来了吧！！！</li><li>推断并设置main方法的定义类。在启动类里面可以有些针对SpringBoot的配置，例如banner还有关闭webContext等。</li></ol><h2 id="run-方法—执行-1"><a href="#run-方法—执行-1" class="headerlink" title="run()方法—执行"></a>run()方法—执行</h2><p>SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><h2 id="run-方法—加载配置参数"><a href="#run-方法—加载配置参数" class="headerlink" title="run()方法—加载配置参数"></a>run()方法—加载配置参数</h2><p>创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile），就是我们刚才所说在yml加载所有可用的参数。联系起来了吧。</p><h2 id="run-方法—回调通知"><a href="#run-方法—回调通知" class="headerlink" title="run()方法—回调通知"></a>run()方法—回调通知</h2><p>遍历所有SpringApplicationRunListener的environmentPrepared()，回调通知已经准备好环境</p><h2 id="run-方法—遍历"><a href="#run-方法—遍历" class="headerlink" title="run()方法—遍历"></a>run()方法—遍历</h2><p> 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p> 钩子ShutdownHook的作用我这里没有深入研究，总之想要优雅关闭，准备一个钩子是最好的，保证所有线程都执行完毕。钩子也可以直接用我的哈哈。</p> <figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LOG.info(<span class="string">"shutdown start"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            LOG.info(<span class="string">"shutdown end"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Main.<span class="keyword">class</span>) &#123;</span><br><span class="line">            running = <span class="literal">false</span>;</span><br><span class="line">            Main.<span class="keyword">class</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><h2 id="run-方法—ApplicationContext"><a href="#run-方法—ApplicationContext" class="headerlink" title="run()方法—ApplicationContext"></a>run()方法—ApplicationContext</h2><p> 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p> 把刚才yml中加载的配置参数加入ApplicationContext中。</p><p> 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p> 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p> 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p> 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><h2 id="run-背后的故事"><a href="#run-背后的故事" class="headerlink" title="run()背后的故事"></a>run()背后的故事</h2><p> 这是run进入的创建SpringBoot的实例最后的一个构造类</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sources = new LinkedHashSet();</span><br><span class="line">    <span class="keyword">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line">    <span class="keyword">this</span>.logStartupInfo = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.addCommandLineProperties = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.addConversionService = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.headless = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.registerShutdownHook = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.additionalProfiles = new HashSet();</span><br><span class="line">    <span class="keyword">this</span>.isCustomEnvironment = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = new LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.<span class="keyword">class</span>));</span><br><span class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.<span class="keyword">class</span>));</span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看有没有我们刚才说的listener和ShutdownHook以及nitializers等，想再再深入就去SpringApplication这个类中看看这里面初始化的一些东西。</p><h2 id="这些代码我教你怎么截"><a href="#这些代码我教你怎么截" class="headerlink" title="这些代码我教你怎么截"></a>这些代码我教你怎么截</h2><p>有人问我，你这些原理和源码怎么收集和找到，我说下，我挺痛苦的。一篇博文至少要搞一下午时间，还要截图、撸码、码字、甚至还要早早搞完手头上的需求。所以有些遗漏在所难免，所以教你怎么去看这些东西吧，就是打Debug。每一个关键点，打上Debug，一层一层执行，框架也是代码码出来的，没有什么难的住的。</p><h2 id="总结执行流程"><a href="#总结执行流程" class="headerlink" title="总结执行流程"></a>总结执行流程</h2><p>SpringBoot启动结构，我们发现启动流程主要分为三个部分：</p><p>第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器；<br>第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块；<br>第三部分是自动化配置模块，该模块作为springboot自动配置核心，在后面的分析中会详细讨论。在下面的启动程序中我们会串联起结构中的主要功能。</p><p>关键点都在SpringApplication这个类里面。</p><p>我们不如来再跟我走一次图示再看一遍流程，方便大家用撸码结合的来看。</p><p><img src="/2019/04/21/SpringBoot改造/run方法入口.jpg" alt></p><p>在该构造方法内，我们可以发现其调用了一个初始化的this方法</p><p>主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法</p><p><img src="/2019/04/21/SpringBoot改造/run&#39;方法执行流程.jpg" alt></p><p>该方法中实现了如下几个关键步骤：</p><ol><li>创建了应用的监听器SpringApplicationRunListeners并开始监听</li><li>加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment。</li><li>配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</li><li><p>创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，我们可以看一下创建方法：<br><img src="/2019/04/21/SpringBoot改造/创建createContext.jpg" alt><br>方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回。<br>ConfigurableApplicationContext类图如下：<br><img src="/2019/04/21/SpringBoot改造/context类图.jpg" alt><br>主要看其继承的两个方向：<br>LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法<br>ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)</p></li><li><p>接下来的refreshContext(context)方法，将是实现Spring-Boot-stater-*的关键。包括spring.factories的加载，bean的实例化等核心工作。</p></li></ol><p>配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p><p>自动化配置的话，你就按照我开篇的思路思考就可以，完全是你在yml写什么相关配置参数，并且在maven中导入相关的依赖，SpringBoot就会自动给你加进入。有没有很爽。总结一个图，虽然是别人的，我感觉很经典的一个导入图。<br><img src="/2019/04/21/SpringBoot改造/自动配置666.jpg" alt></p><p>为什么这么爽，因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖。<br><img src="/2019/04/21/SpringBoot改造/SpringBoot依赖.jpg" alt></p><h2 id="结束的寡逼"><a href="#结束的寡逼" class="headerlink" title="结束的寡逼"></a>结束的寡逼</h2><p>谢谢大家，有问题，下面留言一起探讨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚入职的时候，发现我们接手项目是ssm和SpringBoot混用，这个”混用”听起来奇怪哈？一句话就是很多依赖项用了SpringBoot又用了原生，还用了ssm中的一些写法。直观看上去一句my god～～～&lt;br&gt;对新入职的应届生来说，多少会有混淆，用起来也会很撇脚（碍手？
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://www.nouyc.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.nouyc.com/tags/SpringBoot/"/>
    
      <category term="dubbo" scheme="https://www.nouyc.com/tags/dubbo/"/>
    
      <category term="cloud" scheme="https://www.nouyc.com/tags/cloud/"/>
    
      <category term="kafka" scheme="https://www.nouyc.com/tags/kafka/"/>
    
      <category term="分布式" scheme="https://www.nouyc.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
