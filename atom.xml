<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nou的技术逆袭</title>
  <icon>https://www.gravatar.com/avatar/437514e75b4c3fbc3705e56df986d682</icon>
  <subtitle>大大咧咧、情怀无限</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bulintt.com/"/>
  <updated>2019-04-25T03:24:57.093Z</updated>
  <id>https://bulintt.com/</id>
  
  <author>
    <name>Nou</name>
    <email>709824656@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>破解数据库连接工具navicat（亲测可用）</title>
    <link href="https://bulintt.com/2019/04/25/%E7%A0%B4%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7navicat%EF%BC%88%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <id>https://bulintt.com/2019/04/25/破解数据库连接工具navicat（亲测可用）/</id>
    <published>2019-04-25T03:15:57.000Z</published>
    <updated>2019-04-25T03:24:57.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="破解步骤"><a href="#破解步骤" class="headerlink" title="破解步骤"></a>破解步骤</h2><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h2 id="1-最好下载Navicat-Premium-12版本，至于mac-还是-win-自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。"><a href="#1-最好下载Navicat-Premium-12版本，至于mac-还是-win-自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。" class="headerlink" title="1.最好下载Navicat Premium 12版本，至于mac 还是 win 自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。"></a>1.最好下载Navicat Premium 12版本，至于mac 还是 win 自行选择。另外选择破解版本也要看下网上的介绍。本人用12版本已经够用了。</h2><h2 id="生成秘钥对"><a href="#生成秘钥对" class="headerlink" title="生成秘钥对"></a>生成秘钥对</h2><p>2.生成自己的RSA公钥私钥对<br>    （这里直接使用大神的密钥，也可以自己生成测试可以用）</p><p>这步与windows版破解相同，可以用open ssl工具生成，也可以使用其他工具生成，注意密钥是2048位的，PKCS#8格式<br>为了节省时间，可以使用我提供的一对密钥。<br>公钥：</p><p>—–BEGIN PUBLIC KEY—–<br>MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQB8vXG0ImYhLHvHhpi5FS3g<br>d2QhxSQiU6dQ04F1OHB0yRRQ3NXF5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJX<br>HtQVLXMRms+chomsQCwkDi2jbgUa4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEF<br>h0N89FV4yGLyDLr+TLqpRecg9pkPnOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZS<br>I69sPD9xZRt+EciXVQfybI/2SYeAdXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd<br>+03NU3wvEmLBvGOmNGudocWIF/y3VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/p<br>AgMBAAE=<br>—–END PUBLIC KEY—–</p><p>私钥：</p><p>—–BEGIN RSA PRIVATE KEY—–<br>MIIEogIBAAKCAQB8vXG0ImYhLHvHhpi5FS3gd2QhxSQiU6dQ04F1OHB0yRRQ3NXF<br>5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJXHtQVLXMRms+chomsQCwkDi2jbgUa<br>4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEFh0N89FV4yGLyDLr+TLqpRecg9pkP<br>nOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZSI69sPD9xZRt+EciXVQfybI/2SYeA<br>dXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd+03NU3wvEmLBvGOmNGudocWIF/y3<br>VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/pAgMBAAECggEAK5qZbYt8wenn1uZg<br>6onRwJ5bfUaJjApL+YAFx/ETtm83z9ByVbx4WWT7CNC7fK1nINy20/mJrOTZkgIx<br>x6otiNC4+DIsACJqol+RLoo8I9pk77Ucybn65ZteOz7hVZIU+8j6LzW0KDt6yowX<br>e75r7G/NEpfibNc3Zz81+oDd2x+bHyGbzc9QcePIVuEzkof6jgpbWrQZU14itx9l<br>VxEgj/fbMccvBx8brR/l9ClmDZd9Y6TWsF1rfJpF3+DPeqFkKCiD7PGz3bs4O/Zd<br>ZrfV21ZNVusBW49G6bU63gQVKsOf1qGo3efbAW1HVxgTQ/lExVdcMvdenZm+ADKp<br>L4/wUQKBgQDOfBjn3OC2IerUFu18EgCS7pSjTSibXw+TeX3D5zwszLC091G2rGlT<br>5DihBUhMfesNdpoZynrs4YB6Sz9C3wSGAB8AM/tNvPhtSVtbMHmrdT2DEEKCvLkO<br>RNBnt+8aTu2hGRanw9aL1189gzwrmXK5ZuuURfgLrB9ihrvjo4VznQKBgQCapx13<br>dEA1MwapBiIa3k8hVBCoGPsEPWqM33RBdUqUsP33f9/PCx00j/akwmjgQNnBlAJo<br>Y7LOqPCyiwOkEf40T4IlHdzYntWQQvHhfBwqSgdkTE9tKj43Ddr7JVFRL6yMSbW3<br>9qAp5UX/+VzOLGAlfzJ8CBnkXwGrnKPCVbnZvQKBgQCd+iof80jlcCu3GteVrjxM<br>LkcAbb8cqG1FWpVTNe4/JFgqDHKzPVPUgG6nG2CGTWxxv4UFKHpGE/11E28SHYjb<br>cOpHAH5LqsGy84X2za649JkcVmtclUFMXm/Ietxvl2WNdKF1t4rFMQFIEckOXnd8<br>y/Z/Wcz+OTFF82l7L5ehrQKBgFXl9m7v6e3ijpN5LZ5A1jDL0Yicf2fmePUP9DGb<br>ZTZbbGR46SXFpY4ZXEQ9GyVbv9dOT1wN7DXvDeoNXpNVzxzdAIt/H7hN2I8NL+4v<br>EjHG9n4WCJO4v9+yWWvfWWA/m5Y8JqusV1+N0iiQJ6T4btrE4JSVp1P6FSJtmWOK<br>W/T9AoGAcMhPMCL+N+AvWcYt4Y4mhelvDG8e/Jj4U+lwS3g7YmuQuYx7h5tjrS33<br>w4o20g/3XudPMJHhA3z+d8b3GaVM3ZtcRM3+Rvk+zSOcGSwn3yDy4NYlv9bdUj/4<br>H+aU1Qu1ZYojFM1Gmbe4HeYDOzRsJ5BhNrrV12h27JWkiRJ4F/Q=</p><h2 id="—–END-RSA-PRIVATE-KEY—–"><a href="#—–END-RSA-PRIVATE-KEY—–" class="headerlink" title="—–END RSA PRIVATE KEY—–"></a>—–END RSA PRIVATE KEY—–</h2><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><p>3 安装程序，并替换应用包内容目录中rpk文件的公钥</p><h2 id="安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录-Contents-Resources，编辑rpk文件，将公钥替换并保存。"><a href="#安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录-Contents-Resources，编辑rpk文件，将公钥替换并保存。" class="headerlink" title="安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录 /Contents/Resources，编辑rpk文件，将公钥替换并保存。"></a>安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录 /Contents/Resources，编辑rpk文件，将公钥替换并保存。</h2><h2 id="算出有效的Mac版序列号密钥"><a href="#算出有效的Mac版序列号密钥" class="headerlink" title="算出有效的Mac版序列号密钥"></a>算出有效的Mac版序列号密钥</h2><p>4 使用我算好的密钥可以跳过此步，继续第四步，节省时间。<br>中文版64位密钥序列号： NAVH-T4PX-WT8W-QBL5</p><h2 id="英文版64位密钥序列号：-NAVG-UJ8Z-EVAP-JAUW"><a href="#英文版64位密钥序列号：-NAVG-UJ8Z-EVAP-JAUW" class="headerlink" title="英文版64位密钥序列号： NAVG-UJ8Z-EVAP-JAUW"></a>英文版64位密钥序列号： NAVG-UJ8Z-EVAP-JAUW</h2><h2 id="解密请求码，生成激活码"><a href="#解密请求码，生成激活码" class="headerlink" title="解密请求码，生成激活码"></a>解密请求码，生成激活码</h2><p>打开应用，断网！！！，点击注册，输入密钥 NAVH-T4PX-WT8W-QBL5，然后手动激活<br>复制请求码，使用私钥解密请求码，得到激活码明文<br>注意必须自己解密，因为解密后得到的“DI”是不同的<br>激活码明文示例：<br>{<br>  “K” : “NAVHT4PXWT8WQBL5”,<br>  “P” : “Mac 10.13”,<br>  “DI” : “ODQ2Yjg2ZDBjMTEzMjhh”<br>}<br>在线RSA私钥解密：<a href="http://tool.chacuo.net/cryptrsaprikey" target="_blank" rel="noopener">http://tool.chacuo.net/cryptrsaprikey</a></p><p>将得到的激活码明文进行修改，修改后格式如下<br>{“K”:”NAVHT4PXWT8WQBL5”, “N”:”52pojie”, “O”:”52pojie.cn”, “DI”:”ODQ2Yjg2ZDBjMTEzMjhh”, “T”:1516939200}<br>激活码明文格式最好复制我的，改变 “ “ 内的字符即可，在同一行哦，不要换行，否则激活失败！！！<br>“K” “DI” 都替换成自己机器解密的信息，”N” “O” “T”自己定义</p><p>加密激活码明文，使用私钥加密激活码明文<br>在线RSA私钥加密：<a href="http://tool.chacuo.net/cryptrsaprikey" target="_blank" rel="noopener">http://tool.chacuo.net/cryptrsaprikey</a></p><h2 id="复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活"><a href="#复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活" class="headerlink" title="复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活"></a>复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活</h2><h2 id="完整教程贴图地址"><a href="#完整教程贴图地址" class="headerlink" title="完整教程贴图地址"></a>完整教程贴图地址</h2><p><a href="https://blog.csdn.net/xhd731568849/article/details/79751188" target="_blank" rel="noopener">https://blog.csdn.net/xhd731568849/article/details/79751188</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;破解步骤&quot;&gt;&lt;a href=&quot;#破解步骤&quot; class=&quot;headerlink&quot; title=&quot;破解步骤&quot;&gt;&lt;/a&gt;破解步骤&lt;/h2&gt;&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://bulintt.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Rest微服务构建案例</title>
    <link href="https://bulintt.com/2019/04/24/Rest%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA%E6%A1%88%E4%BE%8B/"/>
    <id>https://bulintt.com/2019/04/24/Rest微服务构建案例/</id>
    <published>2019-04-24T13:41:03.000Z</published>
    <updated>2019-04-25T04:54:16.241Z</updated>
    
    <content type="html"><![CDATA[<p>记住一句话：约定 &gt; 配置 &gt; 编码<br>Rest微服务一个基础构建是整个微服务的一个基础，先说下总体介绍。</p><p>有以下几个部分：<br>             1.mvc、mybatis（一带而过了）<br>             2.maven（坐标、仓库、依赖、聚合、继承）。理论要熟练下。<br>               maven的命令：maven -U clean package install 这是我常用的，也是在更新了包所必备去更新到本地的命令。其他工程才能依赖最新的jar包。</p><pre><code>父工程包含很多子工程，子工程公用的依赖包可以提到父工程中。</code></pre><hr><h2 id="撸码"><a href="#撸码" class="headerlink" title="撸码"></a>撸码</h2><h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h2><p>   （一）构建父工程，分布式开发所必备的建工程流程。构建父工程要点就是maven 的打包packaging要为pom。goupId和artifactId都要起好，否则很容易混淆。<br>   构建完pom父工程后，新构建的pom中有几大几个部分—-<br>            1.头部<project xmlns*****（这个不用我多说了） 2.mark名（组名、项目名、版本号、packaging方式） 3.公共properties 4.dependency （二）构建公共子模块api,在所见父工程上右键鼠标选择new->(重要！)Other-&gt; Maven Moudle。goupId和artifactId都要起好还是一样的要起好，packaging这时侯<br>        变了！变成了jar包。在构建框里面的置灰部分，你也会看见parent的工程也就是上方所说的父工程。点击确定！<br>        创建完毕后，返回头去父工程的pom文件中查看下，发现新增<moudles><moudle>moudleName<moudle></moudle></moudle></moudles><br>        构建实体类的样子记得最好用工具lombok<br>        （1）@AllArgsConstructor<br>            @NoArgsConstructor<br>            @Data<br>            @Accessors(chain = true)<br>            public class entity {<br>                private Long id;<br>                private String msg;<br>                private String DBSource;<br>            }<br>        （2）在yml中配置我们所需要的配置信息，例：mybatis、spring日志config、重要的是spring-application-name！！！！暴露出去的微服务名称。<br>        （3）创建数据库genetator，自动生成mapper、entity、dao。<br>        （4）给数据库造点假数据。对了，这里数据库的库和表要自己建好，否则（3）进行不下去。这一步省去了你很多时间，真正提高工作效率。如何运用，请看管理系统标签<br>        （5）整合service层<br>        （6）整合controller层<br>            都在各层记得打@啊！！！</project></p><pre><code>添加主启动类：SpringApplication.run(所属类,args);启动！done</code></pre><hr><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><p>   构建consumer过程和上方大部分一致，直到（5）部，不再调用service层进行数据库操作了。<br>   这里！！！！在controller中加入@Autowired RestTemplate restTemplate;<br>   操作—<br>           restTemplate.getForObject();//传参3个参数，请求服务的URL（provider的controller地址），传递参数（provider api 对应参数），返回类型（可选boollean、有很多）<br>        restTemplate.postForObject();//同上<br>        添加主启动类：SpringApplication.run(所属类,args);启动！done。实验下，发现consumer的调用直接调到了provider。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本期微服务的构建案例，总结其精髓就是rest api！同时也是和dubbo不同的所在。剩下搞过mvc开发的，熟悉其开发流程的同学来说，只是增添了一些小应用有没有，<br>当然这些都是构建在SpringBoot的基础上搞的，SpringBoot这个框架，本人是真的喜欢，但是喜欢的同时千万要对其自动配置、起步依赖、Actuator、命令行界面<br>要有深入理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记住一句话：约定 &amp;gt; 配置 &amp;gt; 编码&lt;br&gt;Rest微服务一个基础构建是整个微服务的一个基础，先说下总体介绍。&lt;/p&gt;
&lt;p&gt;有以下几个部分：&lt;br&gt;             1.mvc、mybatis（一带而过了）&lt;br&gt;             2.mave
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://bulintt.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>kafka的生产+消费</title>
    <link href="https://bulintt.com/2019/04/23/kafka%E7%9A%84%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9/"/>
    <id>https://bulintt.com/2019/04/23/kafka的生产-消费/</id>
    <published>2019-04-23T10:17:18.000Z</published>
    <updated>2019-04-23T13:38:33.656Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列的内容很丰富，目前我常用的是kafka，所以第一篇献给我的kafka，后续我们继续钻研下，RocketMQ、ActiveMQ。<br>kafka的原生写法，不繁琐，直接看见配置项就👌，如果你是刚入门大数据或者是刚接手kafka的话难免有蒙圈的感觉，But！！！这不要紧，先蒙在其中，后续你接触多了大数据的东西，就会发现，很多组件用了很多的配置项，加载进配置项就可以用了。当然我说的还是比较原生的写法，刚刚写完了一遍HBase的原生，一时脱离不出底层的范围哈哈哈。</p><h2 id="心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码"><a href="#心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码" class="headerlink" title="心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码"></a>心灵鸡汤一下：刚入职的小白遇到不会的问题，甚者被批评，千万不要气馁，觉得自己不适合干这个。行业没有不适合的，只有干的开不开心。坚持一下没准你就有小骄傲了呢？废话少说，开始撸码</h2><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>public class KafkaProvider{</p><pre><code>private final Producer&lt;String, String&gt; producer;public final static String TOPIC = &quot;TEST-TOPIC&quot;;public KafkaProvider(){    Properties props = new Properties();//配置项！这行代码是kafka的源头。    props.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:9092&quot;);//zookeeper地址，集群用逗号分隔      //这里如果不熟悉的同学，可以看看kafa的架构图。每一个      ![](kafka架构.jpg)    props.put(&quot;acks&quot;, &quot;all&quot;);//记录完整提交，最慢但是最大可能的持久化    props.put(&quot;retries&quot;, 3);//请求失败的重试次数    props.put(&quot;batch.size&quot;, 16384);//batch大小    props.put(&quot;linger.ms&quot;, 1);// 默认情况即使缓冲区有剩余的空间，也会立即发送请求，设置一段时间用来等待从而将缓冲区填的更多，单位为毫秒，producer发送数据会延迟1ms，可以减少发送到kafka服务器的请求数据    props.put(&quot;buffer.memory&quot;, 33554432);// 提供给生产者缓冲内存总量    props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);//写话方式    props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);    //生成生产者    producer =  new KafkaProducer&lt;String, String&gt;(props);}//在入口函数调用即可，具体应用情形根据项目实际来看public void producer(){    int messageNo = 1;    final int COUNT =1000;    while (1){        String num = String.valueOf(messageNo);        String data = &quot;hello kafka message:&quot; + num;        ProducerRecord record = new ProducerRecord(TOPIC,data);        producer.send(record);        messageNo ++ ;        System.out.println(messageNo);        try {            sleep(1000);        } catch ( InterruptedException e ) {            e.printStackTrace();        }    }}</code></pre><h2 id><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>public class KafkaConsumer {<br>    private final Consumer consumer ;<br>    public final static String TOPIC = “TEST-TOPIC”;<br>    private ExecutorService executors;</p><pre><code>public KafkaCon(){    Properties props = new Properties();    props.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:9092&quot;);//zk同生产者一致    props.put(&quot;group.id&quot;, &quot;2&quot;);//分组Id！！！！    props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);//自动提交，这是对offset的操作，有些需要对offset更加精准的处理，需要进行手动提交。    props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);    props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);    props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);    props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);    consumer = new KafkaConsumer&lt;String, String&gt;(props);    consumer.subscribe(Arrays.asList(TOPIC));    execute(10);}public void execute(int workerNum) {    executors = new ThreadPoolExecutor(workerNum, workerNum, 0L, TimeUnit.MILLISECONDS,            new ArrayBlockingQueue(1000), new ThreadPoolExecutor.CallerRunsPolicy());    Thread t = new Thread(new Runnable(){//启动一个子线程来监听kafka消息        @Override        public void run(){            while (true) {                ConsumerRecords&lt;String, String&gt; records = consumer.poll(200);                for (final ConsumerRecord record : records) {                    System.out.println(&quot;【Kafka】监听到kafka的TOPIC【&quot; + record.topic() + &quot;】的消息&quot;);                    System.out.println(&quot;【Kafka】消息内容：&quot; + record.value());                    executors.submit(new ConsumerWorker(record));                }            }        }});    t.start();}</code></pre><p>}</p><p>这是标准的一个kafka配置信息，生产实战中的应用很简单，千万记住几个关键词：produce、consumer、topic、group.id、partition、broker，schema的含义，主要还是理解吧。<br>提几个问题哈？如果你想多个消费者消费一个topic怎么办？partion中的消息是顺序的，多个partion间的消息呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息队列的内容很丰富，目前我常用的是kafka，所以第一篇献给我的kafka，后续我们继续钻研下，RocketMQ、ActiveMQ。&lt;br&gt;kafka的原生写法，不繁琐，直接看见配置项就👌，如果你是刚入门大数据或者是刚接手kafka的话难免有蒙圈的感觉，But！！！这不
      
    
    </summary>
    
      <category term="kafka" scheme="https://bulintt.com/categories/kafka/"/>
    
    
      <category term="消息队列，kafka" scheme="https://bulintt.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8Ckafka/"/>
    
  </entry>
  
  <entry>
    <title>java 代码请求URl样例</title>
    <link href="https://bulintt.com/2019/04/23/java-%E4%BB%A3%E7%A0%81%E8%AF%B7%E6%B1%82URl%E6%A0%B7%E4%BE%8B/"/>
    <id>https://bulintt.com/2019/04/23/java-代码请求URl样例/</id>
    <published>2019-04-23T03:36:09.000Z</published>
    <updated>2019-04-23T04:45:44.373Z</updated>
    
    <content type="html"><![CDATA[<p>习惯了在开发中运用工具（postman等）调试接口，几乎忘了用代码可以更好的处理实际情况。</p><hr><p>Demo样例<br>    /**</p><pre><code> * 发送post请求 * @param url  路径 * @param jsonObject  参数(json类型) * @param encoding 编码格式 * @return * @throws ParseException * @throws IOException */public static String send(String url, JSONObject jsonObject,String encoding) throws ParseException, IOException{    String body = &quot;&quot;;    //创建httpclient对象    CloseableHttpClient client = HttpClients.createDefault();    //创建post方式请求对象    HttpPost httpPost = new HttpPost(url);    //装填参数    StringEntity s = new StringEntity(jsonObject.toString(), &quot;utf-8&quot;);    //参数体有按要求也要进行Content-type赋值    s.setContentType(&quot;application/json&quot;);    s.setContentEncoding(new BasicHeader(HTTP.CONTENT_TYPE,            &quot;application/json&quot;));    //设置参数到请求对象中    httpPost.setEntity(s);    System.out.println(&quot;请求地址：&quot;+url);</code></pre><p>//        System.out.println(“请求参数：”+nvps.toString());</p><pre><code>    //设置header信息    //指定报文头【Content-type】、【User-Agent】选择其一就ok    httpPost.setHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);    httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;);    httpPost.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;);    //执行请求操作，并拿到结果（同步阻塞）    CloseableHttpResponse response = client.execute(httpPost);    //获取结果实体    HttpEntity entity = response.getEntity();    if (entity != null) {        //按指定编码转换结果实体为String类型        body = EntityUtils.toString(entity, encoding);    }    EntityUtils.consume(entity);    //释放链接    response.close();    return body;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;习惯了在开发中运用工具（postman等）调试接口，几乎忘了用代码可以更好的处理实际情况。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Demo样例&lt;br&gt;    /**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * 发送post请求
 * @param url  路径
 * @param jsonOb
      
    
    </summary>
    
      <category term="HTTP" scheme="https://bulintt.com/categories/HTTP/"/>
    
    
      <category term="Http" scheme="https://bulintt.com/tags/Http/"/>
    
      <category term="SpringMVC" scheme="https://bulintt.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot改造</title>
    <link href="https://bulintt.com/2019/04/21/SpringBoot%E6%94%B9%E9%80%A0/"/>
    <id>https://bulintt.com/2019/04/21/SpringBoot改造/</id>
    <published>2019-04-21T08:52:10.000Z</published>
    <updated>2019-04-23T13:38:46.245Z</updated>
    
    <content type="html"><![CDATA[<p>刚入职的时候，发现我们接手项目是ssm和SpringBoot混用，这个”混用”听起来奇怪哈？一句话就是很多依赖项用了SpringBoot又用了原生，还用了ssm中的一些写法。直观看上去一句my god～～～<br>对新入职的应届生来说，多少会有混淆，用起来也会很撇脚（碍手？）。但本菜狗认为这真是一个学习的好机会，从最原生的写一遍，写到SpringBoot，写到地老天荒。另外悄悄告诉你，我们的之前组件都是原生的哈哈哈哈，根本没有Compent，你知道怎么实现的吗？</p><p>以上都是废话</p><hr><p>干货</p><p>我介绍下SpringBoot的原理，也偷偷抓紧复习下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚入职的时候，发现我们接手项目是ssm和SpringBoot混用，这个”混用”听起来奇怪哈？一句话就是很多依赖项用了SpringBoot又用了原生，还用了ssm中的一些写法。直观看上去一句my god～～～&lt;br&gt;对新入职的应届生来说，多少会有混淆，用起来也会很撇脚（碍手？
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://bulintt.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://bulintt.com/tags/SpringBoot/"/>
    
      <category term="dubbo" scheme="https://bulintt.com/tags/dubbo/"/>
    
      <category term="cloud" scheme="https://bulintt.com/tags/cloud/"/>
    
      <category term="kafka" scheme="https://bulintt.com/tags/kafka/"/>
    
      <category term="分布式" scheme="https://bulintt.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
